---
layout: post
title: Code Generation with Roslyn - Comparison of SyntaxFactory and CSharpParseTree
---

At Code Connect, we need to generate C# code that runs our user’s unit tests. We devised an internal code framework which discovers relevant methods (e.g. test methods, test initialize and test cleanup) and builds C# code which invokes them in the order that testing framework would invoke them.

We’ve been using [`Microsoft.CodeAnalysis.SyntaxFactory`](http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Syntax/SyntaxFactory.cs,4fb8e71831d97959) for all code generation needs, but its implementation requires really verbose code itself. We decided to test its performance against [`CSharpSyntaxTree.ParseText`](http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Syntax/CSharpSyntaxTree.cs,f4e9b1e7862d75c8)

The task in our benchmark is to generate code that consists of a class and a number of methods. 
To test performance with different sizes of syntax trees, we'll measure the performance when we build between 1 and 4096 methods in a class. Furthermore, we’ll measure the performance when generated methods are empty and when they contains 4 syntactically rich lines of C# code. 

Here’s an example of the code we might generate. It consists of a single class containing method `Run` and a specified number of methods with random identifiers:

```csharp
    public class DemoClass : IDemo
    {
        public void Run()
        {
            method123();
        }

        private void method123()
        {
            var myNumber = Int32.Parse("method123".Substring(6));
            Console.WriteLine("method123 says hi to " + (myNumber + 1));
            System.Diagnostics.Debug.WriteLine("Method {0} executed.", new[] { myNumber });
            var test = myNumber * 2;
        }
    }
```

# Performance analysis

We will compare how long it takes each approach to generate the desired code. The number of methods is the controlled variable. We have tested two approaches of generating syntax, each generating either empty or relatively complex methods. The lower the measurement, the better the approach is.

*The resulting time is milliseconds to generate a type, averaged over 100 samples. Building of the syntax tree was performed in a separate process every time. Standard deviation error bars were too small to be visible on the plot. All data is available [here](https://github.com/CodeConnect/SyntaxFactoryVsParseText/tree/master/data).*

<span class="graphInfo">Code generation time [ms] vs. complexity. **Lower is better**.</span>
![graph](/images/SyntaxFactory-vs-ParseText/graph.png)

When generating a modest amount of methods, `ParseText` is noticeably faster, whether the methods have body or are empty. Let’s see the performance when generating more methods:

<span class="graphInfo">Code generation time [ms] vs. complexity. **Lower is better**.</span>
![graph](/images/SyntaxFactory-vs-ParseText/graphFull.png)

Performance of `SyntaxFactory` is very sensitive to both amount and complexity of generated code, which might be correlated with a high number of object allocations. Depending on complexity of generated code, `SyntaxFactory` might be faster than `ParseText`. 

How many objects were actually allocated? Roughly twice as many in the `SyntaxFactory` approach. However, `SyntaxFactory` kept the Heap Size lower:

`SyntaxFactory` generating 4096 **empty** methods used **83k allocations**
![graph](/images/SyntaxFactory-vs-ParseText/sf4096simple.png)

`ParseText` generating 4096 **empty** methods used **48k allocations**
![graph](/images/SyntaxFactory-vs-ParseText/pt4096simple.png)

`SyntaxFactory` generating 4096 **complex** methods used **470k allocations**
![graph](/images/SyntaxFactory-vs-ParseText/sf4096complex.png)

`ParseText` generating 4096 **complex** methods used **185k allocations**
![graph](/images/SyntaxFactory-vs-ParseText/pt4096complex.png)


At Code Connect, we rarely have a need to create a type with a hundred methods. The most common scenario is creating a type with only one method. In either case, `ParseText` is the fastest and lightest choice. 

# Developer experience

The most noticeable difference is that, `SyntaxFactoryCodeGenerator.cs` has 581 source lines of code, and `ParseTextCodeGenerator.cs` has 86 source lines of code. However, most of the code for the SyntaxFactory experiment was generated by the [Roslyn Quoter](http://roslynquoter.azurewebsites.net/) tool. Most of the changes pertained extracting chunks of code into functions that `yield return`. When in doubt, I used the [Roslyn Syntax Visualizer](https://visualstudiogallery.msdn.microsoft.com/2ddb7240-5249-4c8c-969e-5d05823bcb89) to see the structure of the C# syntax trees.

How does the number of lines translate to amount of errors? Is it proportional in the same way for two approaches? It’s hard to tell:
C# grammar is for the most part unambiguous, so that usually `ParseText` also outputs the tree that you wanted, without you needing to know the detailed structure of the tree. In some situations “usually” in not acceptable, and this method can’t be used.

`SyntaxFactory` extensively uses the type system, and the best thing about `SyntaxFactory` approach is that *it builds exactly what you tell it to build*. The worst thing about `SyntaxFactory` approach is that *it builds exactly what you tell it to build*. Some rules are very stringent and there is no way to bend them. `SyntaxFactory` builds exactly the tree that you, a programmer, literally asked for. **Watch out when you’re manually editing generated code!**

Consider a situation where you need to build a method invocation expression `Method(“one”, 2, 3d);`. Roslyn Quoter provides the following syntax for the `ArgumentList`:

```csharp
SyntaxFactory.SeparatedList<ArgumentSyntax>(
    new SyntaxNodeOrToken[]{
        SyntaxFactory.Argument(
            SyntaxFactory.LiteralExpression(
                SyntaxKind.StringLiteralExpression,
                SyntaxFactory.Literal(
                    SyntaxFactory.TriviaList(),
                    @"""one""",
                    @"""one""",
                    SyntaxFactory.TriviaList()))),
        SyntaxFactory.Token(
            SyntaxKind.CommaToken),
        SyntaxFactory.Argument(
            SyntaxFactory.LiteralExpression(
                SyntaxKind.NumericLiteralExpression,
                SyntaxFactory.Literal(
                    SyntaxFactory.TriviaList(),
                    @"2",
                    2,
                    SyntaxFactory.TriviaList()))),
        SyntaxFactory.Token(
            SyntaxKind.CommaToken),
        SyntaxFactory.Argument(
            SyntaxFactory.PrefixUnaryExpression(
                SyntaxKind.UnaryMinusExpression,
                SyntaxFactory.LiteralExpression(
                    SyntaxKind.NumericLiteralExpression,
                    SyntaxFactory.Literal(
                        SyntaxFactory.TriviaList(),
                        @"3d",
                        3d,
                        SyntaxFactory.TriviaList())))
            .WithOperatorToken(
                SyntaxFactory.Token(
                    SyntaxKind.MinusToken)))})
```

Each of the arguments is a different type of `ExpressionSyntax`. The first two are `LiteralExpression` with `StringLiteralExpression` and `NumericLiteralExpression` inside. The last one is a `PrefixUnaryExpression` which ultimately contains a `NumericLiteralExpression`.

Suppose that the method arguments are supplied by the user as a string `“\”one\”, 2, 3d”`. After splitting this string into three substrings, you must 
choose appropriate LiteralExpression for each one of them.

If you need `NumericLiteralExpression`, you must pass a numeric to SyntaxFactory.Literal as the third parameter. Setting `SyntaxKind.NumericLiteralExpression` doesn’t mean that you will obtain `NumericLiteralExpression`

If you use a wrong expression, the syntax tree won’t compile - but it will appear ok!  Read more about [invalid syntax trees at Josh’s blog](https://joshvarty.wordpress.com/2015/03/30/lrn-quick-tips-dont-trust-syntaxnode-tofullstring/) and add a [test that tries to compile the syntax tree](https://github.com/CodeConnect/SyntaxFactoryVsParseText/blob/master/src/CodeConnect.SyntaxFactoryVsParseText.Tests/TestHelpers.cs#L14).


# Which method to use?

- When convenience and ease of maintenance is relatively most important, use `ParseText`
- To be certain about the generated tree structure - use `SyntaxFactory`
- To generate just one expression - `SyntaxFactory` for precision and correct type, and because `ParseText` may have too little context to identify tokens and nodes in an isolated line of code. `SyntaxFactory.ParseExpression` may also be used to parse an individual line of code.
- To interpret arbitrary C# file - use `ParseText`
- To interpret arbitrary string and build just one expression - use `SyntaxFactory.ParseExpression` or use `ParseText` with `CSharpParseOptions.WithKind(SourceCodeKind.Script`. Support for scripting with C# is a work in progress as of August 2015. We haven’t tested this approach. It is available in nightly builds of Roslyn. See [StackOverflow answer on CSharpParseOptions script for usage](https://stackoverflow.com/questions/32034881/c-sharp-codeanalysis-structure-of-expressions/32038787#32038787). [`SyntaxFactory.ParseExpression`](http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Parser/DirectiveParser.cs,13ed287909d82556) is available in Roslyn v1.0, so take it for a spin!

# Conclusion

Initially I dismissed `ParseText` approach thinking that `SyntaxFactory` is *the closest to the metal* and therefore the fastest. However, `SyntaxFactory` allocates roughly twice as many objects as `ParseText`, which is highly optimized. Read [Robin Sedlaczek’s excellent analysis of Roslyn’s performance](https://robinsedlaczek.wordpress.com/2015/04/29/inside-the-net-compiler-platform-performance-considerations-during-syntax-analysis-speakroslyn/) and if you have an hour, watch [Dustin Campbell’s presentation on performance in a large codebase](https://channel9.msdn.com/Events/TechEd/NorthAmerica/2013/DEV-B333#fbid=). 

### The source code
The source code to the generator is [available on GitHub](https://github.com/CodeConnect/SyntaxFactoryVsParseText)

You can follow the call tree which is identical in both `ParseTextCodeGenerator` and `SyntaxFactoryCodeGenerator`. The entry point is method `GenerateType`, which calls `getAllMembers`. This method calls both `getRunMethod` and `getMethods`. The former calls `getMethodInvocations` and the latter one calls `getMethodBody`. There is an extra step in the `ParseTextCodeGenerator.generateType`: you must get the root of the tree and descend to down the child nodes to find the desired `TypeDeclarationSyntax`.

`ParseText` code generation:
![Screenshot of code generated with Code Connect](/images/SyntaxFactory-vs-ParseText/ptCode.png)

`SyntaxFactory` code generation:
![Screenshot of code generated with Code Connect](/images/SyntaxFactory-vs-ParseText/sfCode.png)



Follow us on Twitter: [@GetCodeConnect](http://twitter.com/GetCodeConnect)
