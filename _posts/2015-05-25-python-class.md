---
layout: post
title: Python 点滴 —— Class
tags: [python]
---

Python 学习笔记--Class
		
1. **Python Class 特性点滴**
	
	支持多重继承
    
    如果没有指定父类，则默认object作为父类
    
    新式类必须继承至少一个父类，直接继承自object的类称为新式类。
    
    创建一个对象： `Myboject = MyNewObject()`。注意没有new操作符。
    
    python支持垃圾回收机制，创建的实列没有被其他变量引用时将被自动回收
    
    最简单的类仅仅作为一个名字空间存在，可以在该类中声明变量，就像在C语言中定义的结构体一样。它仅仅作为容器对象来共享名字空间。
    
    ```
    class MyDate(object):
    	pass
        
    Myobj = MyData()
    Myobj.x = 4
    Myobj.y = 5
    Myobj.x + Myobj.y ## == 9
    Myobj.x * Myobj.y ## == 20
    ## x, y 为实例属性，而非类属性，实例属性是动态的，不需要在构造其构造器中或其他地方为他们事先声明
	```
    
    方法定义在类中（即定义在类中的函数），但只能被实例调用（无有static 方法？有的）。必带一个 *self* 参数。该参数指实例本身，由解释器自动传入。
    
    Pyhon 类没有构造器，但有一个类似构造器的特殊方法 *\_\_init\_\_()* 在创建一个新对象时被调用，即在实例创建后，在实例化过程中被调用来做一些额外的工作，其调用是在实例化调用返回实例之前。可认为，实例化是对*\_\_init\_\_()*方法的隐式调用。**定义 *\_\_init\_\_()* 方法时依然要给出 *self* 参数**。
    
    子类如果没有定义*\_\_init\_\_()* 函数，则父类的*\_\_init\_\_()*函数将被调用；如果子类实现自己的*\_\_init\_\_()*函数——即子类重写（覆盖）了父类的*\_\_init\_\_()*函数，则必须显式调用才会执行父类的*\_\_init\_\_()*函数。
    
    
    ***类和函数的相同处：***
    
    ```
    声明类似——头一行一个相应的关键字，接下来是作为它的定义的代码体；
    都允许在其定义中创建函数，闭包或者内部方法，还有类中定义方法；
	```
    
    ***不同处：***
    
	```
    你运行函数
    而会用类来创建一个对象
    类就像一个Python 容器类型
    
    Python Class不支持纯虚函数或抽象方法，你可以在基类方法中引发 *NotImplementError* 异常来获得类似的效果。

	```
    
2. **Class对象**

	**函数式语言  VS  面向对象语言**
    
    ```
	函数式语言以函数（及函数逻辑过程）为中心
    
    面向对象语言以类（及类的实例）为中心
	```
	
    类就像一个Python容器类型。
    
    类是一个对象，就如同函数是一个对象一样。**Python 中，一切都是对象。**
    
    ***Class的定义和声明:***
    
    ```
    含class关键字的首行为声明
    跟在首行后的类体（代码块）为定义（不包含类文档）
    ```
    
    属性包括对象的数据和函数元素。
    
    有趣的是属性也是一个对象，它包含有自己的属性，这样就形成一个属性链。
    
    类属性仅仅与类相绑定，它和任何实例都无关。属于“静态”数据。相当与java或C++程序中被冠以static关键字的变量。
    
    类属性相其他任何普通变量一样，在类被创建后即可被使用。并且可由类方法跟新，也可以在主程序中其他地方被更新。
    
    类属性通常用来跟踪与类相关的值。
    
    类定义中定义的函数称为类的函数属性（方法）；
    
    方法虽然是类的属性，但不能通过类来直接调用，因其没有与类直接bind（绑定）。方法必须绑定到一个实例才能被调用。非绑定的方法可能可以被调用，但一定要给出实例变量作为第一个入参（还记得 ***self*** 形参吗？）。
    
    获取一个类都有那些属性有两种方法： *dir()* 内建函数；及访问类的 *\_\_dict\_\_* 字典属性——所有类具有的特殊属性之一。
    
    内建函数 *vars()* 接受对象作为参数，返回该对象的类的 *\_\_dict\_\_* 属性内容。
    
    文档字符串不能被派生类继承。
    
    访问类属性时，解释器会在类的 *\_\_dict\_\_* 属性中搜索，如果没找到，则从父类的 *\_\_dict\_\_* 属性中搜索，采用深度优先的搜索顺序，基类集合是采用定义时的顺序从左到右的进行搜索。
   	
    类可看作一种数据类型定义，只是这种数据类型可以添加动作（方法）；
    
3. 实列
	指那些主要用在运行时期的对象，由类被实例化得到。
    
    通过调用类对象来创建实例（采用函数记法来调用一个类）：
    
    ```
    class MyClass(object): #定义类
    	pass
	
    mc = MyClass() #初始化类
	```
    
    *\_\_del\_\_()* 函数类似与析构函数，但并不是析构函数。该函数必须有点调用基类的*\_\_del\_\_()*函数。该函数仅在对象引用为0时有python回收程序调用。轻易不要实现（覆盖）该函数，除非你非常清楚自已为什么要重写它。
    
    实例仅仅有数据属性。这些属性独立于类和其他实例。
    
    实例属性可在实例创建后的任何时候创建。即能够在运行中添加属性。其中构造函数 *\_\_init\_\_（）* 是设置这些属性的关键点。
    
    构造函数 *\_\_init\_\_（）* 是可以设置这些属性的最早时刻。其中该函数的默认参数提供了一个有效的方法来初始化实例。**默认参数应该是不变的对象**。
    
    函数的所有灵活特性都可以应用到方法中去，比如在实例化时可变长度参数也是一个很好的特性。
    
    构造函数 *\_\_init\_\_（）*只能返回 **None**。
    
    *dir()* 也可以打印实例属性（该函数同样适用于内建类型）。实例也有一个*\_\_dict\_\_*属性（内建类型中不存在该属性）。
    
    ***类属性 VS 实例属性：***
    
    ```
	类和实例都是名字空间，类是类属性的，实例则是实例属性的。
    
    可用类来访问类属性，如果实例中没有同名的属性的话，也可以用实例来访问。
    
    只可以用类来跟新类属性的值，尝试用实例更新类属性的值则会为实例创建一个同名的实例属性。
    
    与普通Python变量一样，任何对实例属性的赋值都会创建一个实例属性（如果不存在的话），并对其赋值。
    
    但当类属性是可变对象时，则通过实例对该属性的更新并不会创建实例属性，而是直接更新类属性，但通过实例并不能删除该属性。
    
    **修改类属性当使用类名而不是实例名**
	```
    
4. Bind 绑定
	
    方法仅仅是类内定义的函数（方法是类的属性而不是实例的）。
    
    方法只有在其所属类拥有实例时才能被调用。当存在一个实例，方法才被认定为绑定到了那个实例。
    
    任何方法的第一个参数就是 *self*， 它表示调用此方法的实例对象。
    
    调用非绑定方法的主要场景产生在派生类的构造函数中，派生类没有父类的实例，但不得不对父类进行初始化，此时就已自己的实例为参数（因为派生自父类。所以可以代替父类的实例）来调用父类的构造方法。注意该调用应在子类构造函数的第一行语句进行，因为此时子类实例还没有过多的自己的属性，所以此时它最像父类实列。
    
5. 静态方法和类方法
	
    和C++和java中的这类方法一样
    
    使用模版函数比使用静态类方法更常见。
    
    静态函数和类函数第一个参数不用是self。
    
    类方法第一个参数为类，常习惯用 *cls* 来表示
    
    使用 ***staticmethod()*** 和 ***classmethod()*** 内建函数作为装饰器来分别来声明静态和类函数。
    
    
6. 继承
    
    继承描述基类的属性如何“遗传”给子类。子类可继承基类的任何属性，包括数据和方法属性。
    
    父类的中的同名方法被子类覆盖（如同数据属性一样），可通过未绑定方法来调用父类被覆盖的方法（已子类实例为参数），也可以通过 ***super（）*** 来调用。
    
    子类重写的 ***\_\_init\_\_()*** 不会被自动调用，而是需要显式调用，再次强烈推荐 ***super()*** 方法。
    
    
7.    
    
