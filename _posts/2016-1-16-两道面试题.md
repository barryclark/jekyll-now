---
layout: post
title: 记两道面试题
---




> 输出n位的整数，使整数中相邻的两位整数数字差的绝对值大于等于4。输出所有满足此条件的整数。
例如：输入：n=5; 输出：37051,38051,39051，…

就是简单的递归查询吧，现在对这个还熟悉了点，不过代码感觉能再优化点


	public int getNumbers(int n) {
		
		
		int[] numbers = new int[10];
		
		for (int i = 0; i < numbers.length; i++)
			numbers[i] = i;
		
		if ( n <= 0 )
			return 0;
		
		int temp = 0;
		dfs(0, 0, n, temp);
		return counter;
	}
	
	
	
	static int counter = 0;
	private static void dfs(int depth, int lastNumber, int n, int temp) {
		
		if ( depth > n ) {
			System.out.println(temp);
			counter++;
			return;
		}
		
		for ( int i = 0; i < 10; i++ ) {
			if ( 0 == depth ) {
				if ( 0 == i )
					continue;
				temp = 10 * temp + i;
				dfs(depth + 1, i, n, temp);
				temp = temp / 10;
			}
			
			
			else {
				
				if ( Math.abs( i - lastNumber ) >= 4 ) {
					temp = 10 * temp + i;
					dfs(depth + 1, n, temp);
					temp = temp / 10;
				}
				
			}
			
		}
		
		
		
	}



> 一个长度为n的字符串s，如果对于任意i(0<=i<=n-1且i!=n-i-1)时，满足s[i]!=s[n-i-1](下标从0开始)，那么我们称之为反回文串。
例如："c","cpp","java"都是反回文串，
          "test","xiaomimiliao!"则不是反回文串。
请实现下面的函数，重排给定的一个字符串，使它成为字典顺序最小的反回文串。
例如：s="test",结果为"estt",("estt"<"sett")


思路是先对字符串排序，然后对字符数组进行DFS遍历，加入的时候注意：①如果加入的字符注定是前半部分，直接加入，如果加入的是后半部分，比较它和对应的字符，如果相等继续，否则不继续。

代码如下，感觉还需要优化：

	public static String output(String str) {
		
		if ( null == str || 0 == str.length() )
			return str;
		
		
		char[] temp = str.toCharArray();
		
		Arrays.sort(temp);
		
		
		boolean[] used = new boolean[ temp.length ];
		
		
		StringBuilder result = new StringBuilder();
		return dfs( 0, temp, used, result );
		
	}
	
	
	private static String dfs(int index, char[] data, boolean[] used, StringBuilder temp ) {
		
		if ( index >= data.length ) 
			return temp.toString();
		
		
		for (int i = 0; i < data.length; i++) {
			
			if ( used[i] )
				continue;
			
			if ( 1 == data.length % 2 && index == data.length / 2 ) {
				
				temp.append( data[i] );
				used[i] = true;
				String result = dfs( index + 1, data, used, temp );
				
				if ( null == result ) {
					temp.deleteCharAt( temp.length() - 1 );
					used[i] = false;
				}
				
				else 
					return result;
			}
				
			
			
			if ( index < data.length / 2 ) {
				
				temp.append( data[i] );
				used[i] = true;
				String result = dfs( index + 1, data, used, temp );
				
				if ( null == result ) {
					temp.deleteCharAt( temp.length() - 1 );
					used[i] = false;
				}
				
				else
					return result;
			}
			
			
			else {
				if ( data[i] != temp.charAt( data.length - 1 - index ) ) {
					temp.append( data[i] );
					used[i] = true;
					String result = dfs( index + 1, data, used, temp );
					if ( null == result ) {
						temp.deleteCharAt( temp.length() - 1 );
						used[i] = false;
					}
					
					else
						return result;
				}
			}
		}
		
		
		return null;
		
		
		
		
		
		
		
	}
