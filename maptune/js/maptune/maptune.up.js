/**********************************************************************
map_up.js

$Comment: provides JavaScript for Google Mashup from geojson layer generated by maptune
$Source :map_up.js,v $

$InitialAuthor: guenter richter $
$InitialDate: 2010/09/22 $
$Author: guenter richter $
$Id:map_up.js 1.0 2010-09-22 17:30:35Z Guenter Richter $

Copyright (c) Guenter Richter
$Log:map_up.js,v $
**********************************************************************/

/** 
 * @fileoverview This file is the main JavaScript for Google Mashup from geojson layer data created by maptune
 *
 * @author Guenter Richter guenter.richter@maptune.com
 * @version 1.0
 */

/**
 * define namespace maptune
 */

var maptune = window.maptune = window.maptune || {};
(function() {

/* ...................................................................* 
 *  local vars                                                       * 
 * ...................................................................*/ 

var fShowLinkInList = false;
var fEmbedAudioInInfo = true;
var fShowTooltips = false;
var fScrollFixListHeader = true;
var fCenterMapToInfoMarker = false;

var fFullScreen = false;
var actualInfoMarker = null;
var requestInfoMarker = null;

var _mapup_szDefaultMarker="resources/markers/marker.png";
var _mapup_szDefaultSmallMarker="resources/icons/default/default-small_blue.png";

// var _mapup_szItemHighlight = "#DAD9D6"; // #eaefff"; //"#b8ff77";

var _mapUp = null;

var MapUp = null;

/* ...................................................................* 
 *  MapUp Class                                                       *
 * ...................................................................*/
/**
 * Create a new Map Application instance.  
 * @class the main namespace for all map properties and methods.
 * @constructor
 * @throws 
 * @return A new MapUp
 */
maptune.MapUp = MapUp = function(map,mapDiv,itemDiv,legendDiv) {

	/** holds a Google Maps map object */
	this.map = map;
	/** holds a Google Maps map target div */
	this.mapDiv = mapDiv;
	/** holds actual pan */
	this.actualMapCenter = null;
	/** holds actual zoom */
	this.actualMapZoom = null;
	/** holds actual map bounds */
	this.actualMapBounds = null;
	/** not synchronized to zoom and pan */
	this.fSynchronized = false;
	/** array to hold service layer handles (e.g. panoramio, traffic) */
	this.serviceLayerOverlayA = new Array(0);
	/** holds the layer objects of the map */
	this.layer = new Array(0);
	/** holds icons actually in legend */
	this.iconlist = new Array(0);
	/** holds an optional marker clusterer */
	this.markerClusterer = (typeof(MarkerClusterer)!="undefined")?new MarkerClusterer(map,null,{gridSize:50}):null;
	/** holds an optional marker clusterer */
	this.markerDeclutter = (typeof(MarkerDeclutter)!="undefined")?new MarkerDeclutter(map):null;
	/** holds an optional timeline object */
	this.timeline = null;
	/** holds an optional search string  */
	this.szSearchString = null;
	/** holds an optional exclude string */
	this.szExcludeString = null;
	/** holds optional layer spezific search strings  */
	this.szSearchStringA = new Array();
	
	/** holds the DOM object of the DIV containing the item list */
	this.itemListDiv = itemDiv?itemDiv:document.getElementById("itemlist");
	/** holds the DOM object of the DIV containing the marker legend */
	this.legendDiv = legendDiv?legendDiv:document.getElementById("legend");

	// create the item list
	if (this.itemListDiv){
		this.itemListDiv.innerHTML = "<ul id='sidebar-list'><li></li></ul>";

		/** holds the DOM object of the item list */
		this.itemList = this.itemListDiv.firstChild;
	}else{
		this.itemList = null;
	}

	/** flag to show tooltips on mouse over */
	this.fMapTooltips = true;

	/** flag to clip item list to visible marker */
	this.fClipSidebarToMapExtent = true;

	/** flag to scroll automatic to highlighted sidebar item */
	this.fAutoScrollSidebar = true;

	/** flag to allow tooltips by onover sidebar item */
	this.fSidebarTooltips = true;

	/** flag to scroll automatic ti highlighted sidebar item */
	this.fSidebarTooltipsAutoPan = true;

	/** flag to freeze legend marker clipping (to visibility) actually not used */
	this.fFixMarkerClipping = false;

	/** flag to switch list state change and delete buttons */
	this.fUseListStateButtons = false;

	/** flag to switch fixed list style nav header */
	this.fScrollFixListHeader = false;

	/** flag to shopw info of active item immediately (also if info in list is switched off) */
	this.fInfoImmediately = false;

	/** flag to shop *collect / *remove buttons */
	this.fCollectItems = false;
	/** check if touch event defined to know if we are on a touch device */
	this.isTouch = ('ontouchend' in window);

	/** must be done, don't know why */
	this.clearLegend();

	_mapUp = this;
};
/**
 * check, if a layer name is already in use
 * if so, the name has to be modified to grant unique layer names
 * @param szName the layer name
 * @return ---
 */
MapUp.prototype.makeUniqueLayerName = function(szName) {
	for ( var i=0; i<this.layer.length; i++ ){
		if ( this.layer[i].name == szName ){
			return this.makeUniqueLayerName(szName+"*");
		}
	}
	return szName;
};

/**
 * check text for image resource strings, if found one, 
 * see if has relative URL, if yes, make abslute using root from given szUrl
 * @param szText the string that might contain image resource definitions
 * @param szUrl  the 'root' URL to resolve the relative url
 * @return ---
 */
MapUp.prototype.resolveRelativeUrls = function(szText,szUrl) {
    var match = szText.split(/src=(?:\"|\')?([^>]*[^/].(?:jpg|jpeg|bmp|gif|png))(?:\"|\')?/i);
	var szImg = (match && (match.length>1))?(match[1]):"";
	if ( szImg && !szImg.match(/http:/i) ){
		var szResolved = "";
		szResolved += match[0];
		szResolved += "src=\"" + __getUrlRoot(szUrl) + match[1] + "\" ";
		szResolved += match[2];
		return szResolved;
	}else{
		return szText;
	}
};
/**
 * check text for image resource strings, if found one, 
 * see if has relative URL, if yes, make abslute using root from given szUrl
 * @param szText the string that might contain image resource definitions
 * @param szUrl  the 'root' URL to resolve the relative url
 * @return ---
 */
MapUp.prototype.resolveRelativeHREF = function(szText,szUrl) {
    var match = szText.split(/href=(?:\"|\')?([^>]*[^/].(?:mp3))(?:\"|\')?/i);
	var szImg = (match && (match.length>1))?(match[1]):"";
	if ( szImg && !szImg.match(/http:/i) ){
		var szResolved = "";
		szResolved += match[0];
		szResolved += "href=\"" + __getUrlRoot(szUrl) + match[1] + "\" ";
		szResolved += match[2];
		return szResolved;
	}else{
		return szText;
	}
};
/**
 * check layer for properties.descriptions and call .resolveRelativeUrl() 
 * @param layer the layer object to be scanned
 * @param szUrl the 'root' URL to resolve the relative url
 * @return ---
 */
MapUp.prototype.resolveRelativeUrlsOfLayer = function(layer,szUrl) {
    
	if ( !layer || typeof(layer)!=="object" || !szUrl || typeof(szUrl)!=="string" || !szUrl.match(/http:/i) ){
		return;
	}

	if ( layer.features ){
		for ( var i=0; i<layer.features.length; i++ ){
			layer.features[i].properties.szUrl = szUrl;
			layer.features[i].properties.description = this.resolveRelativeUrls(layer.features[i].properties.description,szUrl);
			layer.features[i].properties.description = this.resolveRelativeHREF(layer.features[i].properties.description,szUrl);
		}
	}else{
		if ( layer.layers ){
			for ( var ii=0; ii<layer.layers.length; ii++ ){
				this.resolveRelativeUrlsOfLayer(layer.layers[ii],szUrl);
			}
		}
	}
};
MapUp.prototype.sortFeaturesUp = function(a,b) {

	if(a.properties.name < b.properties.name) return -1;
    if(a.properties.name > b.properties.name) return 1;
    return 0;
};
MapUp.prototype.sortFeaturesDown = function(a,b) {

	if(a.properties.name < b.properties.name) return 1;
    if(a.properties.name > b.properties.name) return -1;
    return 0;
};
MapUp.prototype.sortFeaturesUpByTime = function(a,b) {
	if ( a.properties.utime ){
		if(a.properties.utime < b.properties.utime) return -1;
		if(a.properties.utime > b.properties.utime) return 1;
	}
	if ( a.properties.utimeStart ){
		if(a.properties.utimeStart < b.properties.utimeStart) return -1;
		if(a.properties.utimeStart > b.properties.utimeStart) return 1;
	}
    return 0;
};
MapUp.prototype.sortFeaturesDownByTime = function(a,b) {
	if ( a.properties.utime ){
		if(a.properties.utime < b.properties.utime) return 1;
		if(a.properties.utime > b.properties.utime) return -1;
	}
	if ( a.properties.utimeStart ){
		if(a.properties.utimeStart < b.properties.utimeStart) return 1;
		if(a.properties.utimeStart > b.properties.utimeStart) return -1;
	}
    return 0;
};
/**
 * sort the layer  
 * @param layer the layer object to be sorted
 * @return ---
 */
MapUp.prototype.sortLayerFeatures = function(layer,szType) {
    
	if ( !layer || typeof(layer)!=="object" ){
		return;
	}

	if ( layer.features ){
		if ( szType == "timeUp" ){
			layer.features.sort(this.sortFeaturesUpByTime);
		}else
		if ( szType == "timeDown" ){
			layer.features.sort(this.sortFeaturesDownByTime);
		}else
		if ( szType == "down" ){
			layer.features.sort(this.sortFeaturesDown);
		}else{
			layer.features.sort(this.sortFeaturesUp);
		}
	}else{
		if ( layer.layers ){
			for ( var ii=0; ii<layer.layers.length; ii++ ){
				this.sortLayer(layer.layers[ii]);
			}
		}
	}
};




/**
 * loads the layer (and sub layer) of the given GeoJson data object
 * (szSourceName) into the layer object (layer list) of MapUp
 * @param szSourceName the GeoJson data file name (may have more than one layer)
 * @param source the GeoJson data object
 * @return ---
 */
MapUp.prototype.addLayer = function(szSourceName,source) {

	_TRACE("addLayer: "+szSourceName);

	if ( source === null ){
		return;
	}
	this.data = source;
	
	var szTitle = source.title;
    var isLayeri = null;
    
    // we put new layer into a temporary array so we can concat to the existant
    // in a way that new layer are on top
	var tempLayerA = new Array(0);

	var layerCount = source.layers.length;
	for ( var i=0; i<layerCount; i++ ){
        
		var layer = source.layers[i];
		if (!layer){
			continue;
		}

		// GR 12.01.2013 test resolving relative image urls with the layer source url
		this.resolveRelativeUrlsOfLayer(layer,source.szSourceUrl);

		var defaultIcon = layer.icon?layer.icon:_mapup_szDefaultMarker;
        
        var bBox =  new Array(-180,-90,180,90);
        if ( source.bbox ){
			bBox = source.bbox.slice(0);
		}
		if ( bBox[0] === 0 && bBox[1] === 0 && bBox[2] === 0 && bBox[3] === 0  ){
			bBox =  new Array(-100,-10,100,70);
		}
		if ( !layer.properties || typeof(layer.properties) == "undefined" ){
			alert("layer: "+szSourceName+" - format error !");
			continue;
		}
		var nLower = layer.properties.lower?Number(layer.properties.lower.split(':')[1]):0;
		var nUpper = layer.properties.upper?Number(layer.properties.upper.split(':')[1]):0;
        
		// GR 13.02.2012 if loaded layer is linked source layer, try to take the link place in the layer list
		//	
		if ( maptune.szMasterSource && maptune.szLinkLayer ){

			if ( layer.properties.name != maptune.szLinkLayer ){
				layer.properties.name = maptune.szLinkLayer;
			}
			// if we have only one sublayer, replace link in layer list, if not, create new entry and delete link 
			if ( layer.features || (layer.layers.length == 1) ){
				szSourceName = maptune.szMasterSource;
			}else{
				szSourceName = maptune.szMasterSource;
				this.removeLayer(maptune.szLinkLayer);
			}
			maptune.szMasterSource = null;
			maptune.szLinkLayer = null;
		}

		// GR 29.05.2012 apply layer specific parameter 
		// 
		var layerP = _mapup_getLayerParam(szSourceName);
		if ( layerP && layerP.initListState && (layerP.initListState.match(/collapsed/)) ){
			layer.sourcelegend = layer.legend  = "collapsed";
		}
		if ( layerP && layerP.initListState && layerP.initListState.match(/expanded/) ){
			layer.sourcelegend = layer.legend = "expanded";
		}
		if ( layerP && layerP.initListState && layerP.initListState.match(/hidden/) ){
			layer.properties.visibility = "0";
		}
		if ( layerP && layerP.initListState && layerP.initListState.match(/noinfo/) ){
			layer.fShowInfoInList = false;
		}
		if ( layerP && layerP.initListState && layerP.initListState.match(/showinfo/) ){
			layer.fShowInfoInList = true;
		}
		if ( layerP && layerP.initListState && layerP.initListState.match(/nocontrols/) ){
			layer.fUseListStateButtons = false;
		}else{
			if ( typeof(layer.fUseListStateButtons) == "undefined" ){
				layer.fUseListStateButtons = true;
			}
		}
		// GR 05.05.2014 sort layer items
		if ( layer.sort || (layerP && layerP.sort) ){
			this.sortLayerFeatures(layer,layerP.sort);
		}

		// GR 16.05.2016 define filter
		if ( layerP && layerP.filter ){
			layer.szFilter = layerP.filter;
		}

		// GR 05.06.2016 define upper, lower scale
		if ( layerP && layerP.upper ){
			nUpper = layerP.upper.split(':')[1];
		}
		if ( layerP && layerP.lower ){
			nLower = layerP.lower.split(':')[1];
		}

		// insert layer into layer array
        // ---------------------------------------------------------------------
        
        // 1. layer is link to external resource 
        //
		if ( layer.link ){
			tempLayerA.push({source:szSourceName
                            ,url:source.szSourceUrl
							,parent:source
                            ,name:layer.properties.name
                            ,data:layer
                            ,icon:defaultIcon
                            ,bbox:bBox,upper:nUpper,lower:nLower
                            });
		}
        else
        
        // 2. layer has features -> has no sublayer 
        //
		if ( layer.features ){

			// detect if there is a placeholder for the loaded layer
			isLayeri = this.getLayerIndex(szSourceName,layer.properties.name);
			if ( (isLayeri >= 0) && this.layer[isLayeri].data.link ){
				// yes, then replace it
				this.layer[isLayeri] = { source:szSourceName
										,url:source.szSourceUrl
										,parent:this.layer[isLayeri].parent
										,title:szTitle
										,name:layer.properties.name
										,data:layer
										,icon:defaultIcon
										,bbox:bBox,upper:nUpper,lower:nLower
										};
			}else{

				isLayeri = this.getLayerIndex(layer.properties.name,layer.properties.name);

				if ( (isLayeri >= 0) ){
					// if layer exists, replace it
					console.log(layer);
					console.log(this.layer[isLayeri].data);
					// keep actual legend visibility
					// layer.properties = this.layer[isLayeri].data.properties;
					layer.sourcelegend = layer.legend  = this.layer[isLayeri].data.sourcelegend;
					// layer.sourcelegend = this.layer[isLayeri].data.sourceLegend;
					// remove layer representations on map
					this.clearOneLayer(this.layer[isLayeri]);
					// set the new layer data
					this.layer[isLayeri] = { source:szSourceName
											,url:source.szSourceUrl
											,parent:source
											,title:szTitle
											,name:layer.properties.name
											,data:layer
											,icon:defaultIcon
											,bbox:bBox,upper:nUpper,lower:nLower
											};
				}else{
					// no, append new layer
					tempLayerA.push({source:szSourceName
									,url:source.szSourceUrl
									,parent:source
									,title:szTitle
									,name:layer.properties.name
									,data:layer
									,icon:defaultIcon
									,bbox:bBox,upper:nUpper,lower:nLower
									});
				}
			}

			layer.legend = "expanded";
			if ( !this.szItemFilter && !maptune.jsapi.fShowExpanded ){
				if ( layer.properties.visibility == "0" || layer.properties.open == "0" ){
					layer.legend = "collapsed";
				}
			}
		}
		else
        
        // 3. layer has element layers -> the data is in the sublayer
        //
		if ( layer.layers ){
            
			tempLayerA.push({source:szSourceName
							,url:source.szSourceUrl
							,parent:source
							,title:szTitle
							,name:layer.properties.name
							,data:layer
							,icon:defaultIcon
							,bbox:bBox,upper:nUpper,lower:nLower
							});

            var subLayerCount = layer.layers.length;
			for ( var ii=0; ii<subLayerCount; ii++ ){
				var sublayer = layer.layers[ii];

				if ( sublayer.bbox ){
					bBox = sublayer.bbox.slice(0);
				}
				if ( sublayer && sublayer.features ){

					if ( this.szItemFilter && ( __decode_utf8(sublayer.properties.name) != __decode_utf8(this.szItemFilter) ) ){
						var isLayer = this.getLayer(szSourceName,sublayer.properties.name);
						if ( isLayer ){
							alert("remove!");
							this.removeLayer(sublayer.properties.name);
						}
						continue;
						// sublayer.properties.visibility = "0";
					}

					defaultIcon = sublayer.properties.icon?sublayer.properties.icon:defaultIcon;
					// detect if there is a placeholder for the loaded layer
					isLayeri = this.getLayerIndex(szSourceName,sublayer.properties.name);
					if ( (isLayeri >= 0) && this.layer[isLayeri].data.link ){
						// yes, then replace it
						this.layer[isLayeri] = { source:szSourceName
												,url:source.szSourceUrl
												,parent:layer
												,name:sublayer.properties.name
												,data:sublayer
												,icon:defaultIcon
												,bbox:bBox,upper:nUpper,lower:nLower
												};
					}else{
						// no, then append it
						sublayer.properties.name = this.makeUniqueLayerName(sublayer.properties.name);
						tempLayerA.push({source:szSourceName
										,url:source.szSourceUrl
										,title:szTitle
										,parent:layer
										,name:sublayer.properties.name
										,data:sublayer
										,icon:defaultIcon
										,bbox:bBox,upper:nUpper,lower:nLower
										});
					}

					if ( layer.properties.visibility == "0" ){
						sublayer.properties.visibility = "0";
					}
					sublayer.legend = "expanded";
					if ( !this.szItemFilter && !maptune.jsapi.fShowExpanded ){
						if ( sublayer.properties.visibility == "0" || sublayer.properties.open == "0" ){
							sublayer.legend = "collapsed";
						}
					}

					sublayer.properties.upper = nUpper;
					sublayer.properties.lower = nLower;
					sublayer.properties.legendstyle = layer.properties.legendstyle;
				}
			}	
		}
	}
	
	// if all new layer invisible by zoom level, avert
	var nDynLayerNotVisible = 0;
	var nDynLayerScale = 0;
	for ( var i=0; i<tempLayerA.length; i++ ){
		if ( tempLayerA[i].data.features && !this.isLayerInMapScale(tempLayerA[i]) && tempLayerA[i].upper ){
			nDynLayerScale = tempLayerA[i].upper;
			nDynLayerNotVisible++;
		}
	}
	if ( nDynLayerNotVisible && (nDynLayerNotVisible == (tempLayerA.length-1)) ){
		maptune.confirmMessage("Layer not visible at this scale!<br>Zoom in to see the layer?",function(){
			maptune.jsapi.changeZoomToScale(nDynLayerScale);
		});
	}

	// finally add the parsed layer
	this.layer = tempLayerA.concat(this.layer);

};
/**
 * get the layer by its name and origin
 * @param szSourceName the layer JSON file name
 * @param szName the layer or sublayer name
 * @return the layer object
 */
MapUp.prototype.getLayer = function(szSourceName,szName) {
	for ( var i=0; i<this.layer.length; i++ ){
		if ( this.layer[i].name == szName && ( (szSourceName=="*") || (this.layer[i].source == szSourceName) )){
			return this.layer[i];
		}
	}
	return null;
};
/**
 * get the layer index by its name and origin
 * @param szSourceName the layer JSON file name
 * @param szName the layer or sublayer name
 * @return the index into the layer array
 */
MapUp.prototype.getLayerIndex = function(szSourceName,szName) {

	for ( var i=0; i<this.layer.length; i++ ){
		if ( this.layer[i].name == szName && this.layer[i].source == szSourceName){
			return i;
		}
	}
	return -1;
};
/**
 * get all layer by origin ( json file )
 * @param szSourceName the layer JSON file name
 * @return an array of layer objects
 */
MapUp.prototype.getAllLayerOfSource = function(szSourceName) {

	var ret = [];

	for ( var i=0; i<this.layer.length; i++ ){
		if ( this.layer[i].source == szSourceName){
			ret.push(this.layer[i]);
		}
	}
	return ret;
};
/**
 * returns if layer exists by its name and origin
 * @param szName the layer or sublayer name
 * @return true od false
 */
MapUp.prototype.isLayer = function(szName) {

	for ( var i=0; i<this.layer.length; i++ ){
		if ( this.layer[i].name == szName ){
			return true;
		}
	}
	return false;
};

/**
 * returns if layer of given source exists
 * @param szSourceName the layer source definition
 * @return true od false
 */
MapUp.prototype.isLayerOfSource = function(szSourceName) {

	for ( var i=0; i<this.layer.length; i++ ){
		if ( this.layer[i].url == szSourceName ){
			return true;
		}
	}
	return false;
};
/**
 * remove the layer by its index 
 * @param nIndex the index into the layer array
 * @return ---
 */
MapUp.prototype.removeLayerByIndex = function(nIndex) {

	this.clearOneLayer(this.layer[nIndex]);
	if (this.layer[nIndex].data.refreshTimeout ){ 
		clearTimeout(this.layer[nIndex].data.refreshTimeout);
	}

	this.layer.splice(nIndex,1);
};
/**
 * remove the layer by its name 
 * @param szName the layer or sublayer name
 * @return ---
 */
MapUp.prototype.removeLayer = function(szName) {

	for ( var i=0; i<this.layer.length; i++ ){
		if ( this.layer[i].name == szName ){
			this.removeLayerByIndex(i);
			i--;
		}
	}
};
/**
 * remove all the layer (and sub layer) that had been added by one data source 
 * @param szSourceName the GeoJson data object name
 * @return ---
 */
MapUp.prototype.removeLayerBySourceName = function(szSourceName) {

	for ( var i=0; i<this.layer.length; i++ ){
		if ( this.layer[i].source == szSourceName ){
			this.removeLayerByIndex(i);
			i--;
		}
	}
};
/**
 * remove all the layer (and sub layer) that had been added by one source 
 * @param szSource the source url
 * @return ---
 */
MapUp.prototype.removeLayerBySource = function(szSource) {

	for ( var i=0; i<this.layer.length; i++ ){
		if ( this.layer[i].url == szSource ){
			this.removeLayerByIndex(i);
			i--;
		}
	}
};

/**
 * check if layer has upper/lower scale limits
 * if yes, check against actual map scale
 * @param layer the internal layer object
 * @return ---
 */
MapUp.prototype.isLayerInMapScale = function(layer) {

	if ( 0 || !layer.data.fOverrideScaleDependency ){

		if ( typeof(this.actualMapScale) != "undefined"  ){
			if ( layer.upper && (layer.upper < this.actualMapScale) ){
				return false;
			}
			if ( layer.lower && (layer.lower > this.actualMapScale) ){
				return false;
			}
		}
	}
	return true;
};


/**
 * loads a map provider (Google) service layer (e.s. foto, traffic)
 * @param szServiceUrl Url of the service layer
 * @return ---
 */
MapUp.prototype.loadServiceLayer = function(szServiceUrl) {
	try	{
		var serviceLayer = new GLayer(szServiceUrl);
		if ( serviceLayer ){
			this.map.addOverlay(serviceLayer);
			this.serviceLayerOverlayA[szServiceUrl] = serviceLayer;
		}
	}
	catch (e){
		this.map.loadServiceLayer(szServiceUrl);
		this.serviceLayerOverlayA[szServiceUrl] = szServiceUrl;
	} 
};
/**
 * remove service layer
 * @param szServiceUrl Url of the service layer
 * @return ---
 */
MapUp.prototype.removeServiceLayer = function(szServiceUrl) {
	try {
		this.map.removeServiceLayer(szServiceUrl);
	}
	catch (e){
		this.map.removeOverlay(this.serviceLayerOverlayA[szServiceUrl]);
	}
	this.serviceLayerOverlayA[szServiceUrl] = null;
};
/**
 * clear service layer
 * @return ---
 */
MapUp.prototype.clearServiceLayer = function() {
	for ( var a in this.serviceLayerOverlayA ){
		try {
			this.map.removeServiceLayer(a);
		}
		catch (e){
			this.map.removeOverlay(this.serviceLayerOverlayA[a]);
		}
		this.serviceLayerOverlayA[a] = null;
	}
	// here we clear also the directions overlay
	_map_clearDirections(this.map);
};

/**
 * set map type
 * @return ---
 */
MapUp.prototype.setMapType = function(szType) {
	_map_setMapType(this.map,szType);
};

/**
 * set map tilt
 * @return ---
 */
MapUp.prototype.setMapTilt = function(nTilt) {
	_map_setMapTilt(this.map,nTilt);
};

/**
 * rotate map
 * @return ---
 */
MapUp.prototype.rotateMap = function(nRotate) {
	_map_rotateMap(this.map,nRotate);
};

/**
 * set the zoom and pan of the map
 * @param szMode "maximal", "world", empty
 * @return ---
 */
MapUp.prototype.setExtent = function(szMode,szLayer) {

	if ( !this.map ){
		return;
	}
	if ( this.fSynchronized ){
		return;
	}
	if ( szMode.match(/tolayer/) && szLayer && this.data ){

		// parse JSON map data and set initial viewpoint of named layer
		// ------------------------------------------------------------

		// preset boxfrom loaded data
		var bBox = this.data.bbox;
		if ( bBox && bBox[0] === 0 && bBox[1] === 0 && bBox[2] === 0 && bBox[3] === 0  ){
			bBox =  null;
		}
		// look for box of named layer
		for ( var i=0; i<this.layer.length; i++ ){
			if ( this.layer[i].bbox && 
                 this.layer[i].name == szLayer ){
				bBox = this.layer[i].bbox;
			}
		}
		// if no box yet, look for 1. box found
		if ( bBox === null ){
			for ( var i=0; i<this.data.layers.length; i++ ){
				if ( this.data.layers[i].bbox ){
					bBox = this.data.layers[i].bbox;
					break;
				}
			}
		}
		// look for other layer boxes and made hull
		if ( bBox === null ){
			for ( var i=0; i<this.data.layers.length; i++ ){
				if ( this.data.layers[i].layers ){
					for ( var ii=0; ii<this.data.layers[i].layers.length; ii++ ){
						if ( this.data.layers[i].layers[ii].bbox ){
							if ( bBox === null ){
								bBox = this.data.layers[i].layers[ii].bbox.slice(0);
							}else{
								var xBox = this.data.layers[i].layers[ii].bbox;
								bBox[0] = Math.min(bBox[0],xBox[0]);
								bBox[1] = Math.min(bBox[1],xBox[1]);
								bBox[2] = Math.max(bBox[2],xBox[2]);
								bBox[3] = Math.max(bBox[3],xBox[3]);
							}
						}
					}
				}
			}
		}

		// if no box found at all, set to world extension
		if ( bBox === null || bBox === 'undefined' ){
			bBox =  new Array(-100,-10,100,70);
		}

		// GR 26.03.2013 if already visible, don't zoom to
		if ( !szMode.match(/extent/) && this.isBoxInMapBounds(this.map,bBox) ){
			return;
		}

		var __lastZoom = this.actualMapZoom;

		_map_setMapExtension(this.map,bBox);

		this.actualMapCenter = _map_getCenter(this.map);
		this.actualMapZoom = _map_getZoom(this.map);

		if ( this.actualMapZoom > 15 ) {
			this.changeZoom(15-this.actualMapZoom);
		}

		if ( this.actualMapZoom != __lastZoom ){
			this.clearMap();
		}

		return;
	}
	if ( (szMode == "maximal") && this.data ){

		// parse JSON map data and set initial viewpoint
		// ---------------------------------------------
		var bBox = this.data.bbox;

		// look for other layer boxes and made hull
		for ( var i=0; i<this.layer.length; i++ ){
			if ( this.layer[i].bbox ){
				if ( i === 0 ){
					bBox = this.layer[i].bbox.slice(0);
				}else{
					var xBox = this.layer[i].bbox;
					bBox[0] = Math.min(bBox[0],xBox[0]);
					bBox[1] = Math.min(bBox[1],xBox[1]);
					bBox[2] = Math.max(bBox[2],xBox[2]);
					bBox[3] = Math.max(bBox[3],xBox[3]);
				}
			}
		}

		_map_setMapExtension(this.map,bBox);

		// create visible bounding box (for testing only) 
		if ( 0 ){
			var polyPoints = Array();
			polyPoints.push(new GLatLng(bBox[2],bBox[0]));
			polyPoints.push(new GLatLng(bBox[2],bBox[1]));
			polyPoints.push(new GLatLng(bBox[3],bBox[1]));
			polyPoints.push(new GLatLng(bBox[3],bBox[0]));
			polyPoints.push(new GLatLng(bBox[2],bBox[0]));
			var polygon = new GPolygon(polyPoints,"red",5,0.7,"white",0);
			this.map.addOverlay(polygon);
		}
		this.actualMapCenter = _map_getCenter(this.map);
		this.actualMapZoom = _map_getZoom(this.map);

		this.clearMap();

		return;
	}

	if ( (szMode == "actual") ){

		if ( this.actualMapCenter ){
			_map_setCenterAndZoom(this.map,this.actualMapCenter,this.actualMapZoom);
			return;
		}else
		if ( this.actualMapBounds ){
			var box = [];
			box.push(this.actualMapBounds[0].lng);
			box.push(this.actualMapBounds[0].lat);
			box.push(this.actualMapBounds[1].lng);
			box.push(this.actualMapBounds[1].lat);
			_map_setMapExtension(this.map,box);
			_map_setZoom(map,this.actualMapZoom+1);
		}else{
			this.setExtent("maximal");
		}
		return;
	}


	if ( this.actualMapCenter && this.actualMapZoom) {
		_map_setCenterAndZoom(this.map,this.actualMapCenter, this.actualMapZoom);
	}
	else if ( (szMode == "world") ){
		_map_setCenterAndZoom(this.map,new GLatLng(0,0), 1);
	}
};
/**
 * set the zoom and pan of the map
 * @param szMode "maximal", "world", empty
 * @return ---
 */
MapUp.prototype.setView = function(center,zoom) {
	_map_setCenterAndZoom(this.map,new GLatLng(center[0],center[1]), zoom);
};

/**
 * change the map zoom 
 * @param nDelta zoom change value ( -5 <> 5 )
 */
MapUp.prototype.changeZoom = function(nDelta) {
	_map_setZoom(this.map,this.actualMapZoom+nDelta);
	this.actualMapZoom = _map_getZoom(this.map);
};
/**
 * change the map zoom to a scale
 * @param nDelta zoom change value ( -5 <> 5 )
 */
MapUp.prototype.changeZoomToScale = function(nScale) {

//	this.actualMapScale = __zoomToScale[this.actualMapZoom];
	while( __zoomToScale[this.actualMapZoom] > nScale ){
		this.actualMapZoom++;
	}
	_map_setZoom(this.map,this.actualMapZoom);

};
/**
 * draw a layer; create the overlays 
 * @return true or false
 */
MapUp.prototype.drawLayer = function() {

	for ( var i=0; i<this.layer.length; i++ ){
		if ( this.layer[i].data.properties.visibility == "1" && !this.layer[i].data.link ){
			this.makeLayer(this.map,this.layer[i],this.layer[i].defaultIcon);
			this.makeLegend(this.map,this.layer[i].data,this.layer[i].defaultIcon,this.iconlist);
		}
	}
};
/**
 * redraw a layer; create or remove the overlays as for the given visibility
 * @return true or false
 */
MapUp.prototype.redrawLayer = function() {

	for ( var i=0; i<this.layer.length; i++ ){

		var type = this.layer[i].parent.parent?this.layer[i].parent.parent.type:this.layer[i].parent.type;
		if ( maptune.jsapi.szLayerType &&
			 !eval("type.match(/"+maptune.jsapi.szLayerType+"/)") ){
			this.clearOneLayer(this.layer[i]);
		}else{
			if ( this.layer[i].data.properties.visibility == "1" && !this.layer[i].data.link ){
				this.makeLayer(this.map,this.layer[i],this.layer[i].defaultIcon);
				this.makeLegend(this.map,this.layer[i].data,this.layer[i].defaultIcon,this.iconlist);
			}
			else{
				this.clearOneLayer(this.layer[i]);
			}
		}
	}
};
/**
 * clear map and remove all overlays 
 * @return true or false
 */
MapUp.prototype.clearMap = function() {
	for ( var i=0; i<this.layer.length; i++ ){
		if ( this.layer[i].source ){
			maptune.jsapi.setDataCheckBox(this.layer[i].source,false);
		}
		this.clearOneLayer(this.layer[i]);
	}
	if ( this.map && this.map.clearOverlays ){
		this.map.clearOverlays();
	}
	// also clear sevice layer 
	this.clearServiceLayer();



};
/**
 * remove overlays of one layer
 * @return true or false
 */
MapUp.prototype.clearOneLayer = function(layer) {
	var markers = layer.data.features;
	if ( markers ){
		for(var i=0; i < markers.length; i++) {
			this.clearOneObject(markers[i]);
		}
	}
	if ( this.timeline && layer.data.duration ){
		this.timeline.removeLayer(layer);
	}
	if (layer.data.refreshTimeout ){
		clearTimeout(layer.data.refreshTimeout);
	}

};
/**
 * remove overlays of one layer
 * @return true or false
 */
MapUp.prototype.clearOneObject = function(marker) {
	if ( marker && marker.gOverlayObject ){

		if ( marker.gOverlayObject == actualInfoMarker ){
			try{
				if ( typeof(this.infoBubble) != "undefined" && this.infoBubble ){
					this.infoBubble.close();
				}else{
					this.map.closeInfoWindow();
				}
			}
			catch (e){}
			actualInfoMarker = null;
		}
		if (marker.gOverlayObject.tooltip){
			this.map.removeOverlay(marker.gOverlayObject.tooltip);
		}
		this.map.removeOverlay(marker.gOverlayObject);
		// GR 14.01.2012 remove from clusterer, if present
		if (this.markerClusterer !== null) {
          this.markerClusterer.removeMarker(marker.gOverlayObject,true);
        }
		// GR 14.01.2012 remove from clusterer, if present
		if (this.markerDeclutter !== null) {
          this.markerDeclutter.removeMarker(marker.gOverlayObject,true);
        }
		marker.gOverlayObject = null;

		if ( marker.gOverlayObjectPartsA ){
			for ( var part=0; part<marker.gOverlayObjectPartsA.length; part++ ){
				if (marker.gOverlayObjectPartsA[part].tooltip){
					this.map.removeOverlay(marker.gOverlayObjectPartsA[part].tooltip);
				}
				this.map.removeOverlay(marker.gOverlayObjectPartsA[part]);
			}
			marker.gOverlayObjectPartsA = null;
		}
	}
};
/**
 * show the tooltips of all overlayobjects  
 * @return true or false
 */
MapUp.prototype.showTooltips = function(fShow) {

	for ( var i=0; i<this.layer.length; i++ ){
		var markers = this.layer[i].data.features;
		if ( markers ){
			for(var ii=0; ii < markers.length; ii++) {
				if ( markers[ii] && markers[ii].gOverlayObject ){
					if( markers[ii].gOverlayObject.tooltip ){
						markers[ii].gOverlayObject.tooltip.hide();
						if (fShow){
							markers[ii].gOverlayObject.tooltip.show();
						}
					}
				}
			}
		}
	}
};

/**
 * draw sidebar 
 * @return true or false
 */
MapUp.prototype.drawSidebar = function() {

	if ( !this.itemList ){
		return;
	}

	if ( (maptune.jsapi.mapParam && maptune.jsapi.mapParam.header) ){
		var szHTML = "";
		var listItem = document.createElement("div");
		listItem.setAttribute("style","");
		$(maptune.jsapi.mapParam.header).appendTo(listItem); 
		this.itemList.appendChild(listItem);
	}

	var nLayer = 0;
	var nItems = 0;
	for ( var i=0; i<this.layer.length; i++ ){
		this.layer[i].data.source = this.layer[i].source;
		this.layer[i].data.parent = this.layer[i].parent;
		if ( this.makeItemList(this.layer[i]) ){
			nLayer += 1;
			nItems += this.layer[i].data.features?this.layer[i].data.features.length:0;
		}
	}

	if ( !nLayer ){
		var paragraph = document.createElement("p");
		var szEmpty = (maptune.jsapi.mapParam && maptune.jsapi.mapParam.noItemText)?maptune.jsapi.mapParam.noItemText:"(empty)";
		paragraph.innerHTML = szEmpty;
		this.itemList.appendChild(paragraph);
		eval(maptune.jsapi.mapParam.noItemCall);
		try{
			$("#statusline")[0].innerHTML = "";
		} catch (e) {}
	}else{
		try{
			$("#statusline")[0].innerHTML = String(nLayer)+" layer "+String(nItems)+" items ";
		} catch (e) {}
	}

	// for IE make all text unselectable to avoid blue selection trap; GR 21.11.11
	// __makeUnselectable(document.getElementById("footerloading"));
	// __makeUnselectable(document.getElementById("sidebar"));

	// try to scroll to the last layer header item
	this.setSavedSidebarScroll();
    
	if ( !this.fUseListStateButtons && ($("#sidebar-footer")[0]) ){
		var szHTML = "";
		szHTML += "<div class=\"listitemcontrolgroup\" >";
		szHTML += "<a class=\"listitemcontrol\" title=\"cambia contenuto del elenco\" href=\'javascript:maptune.jsapi.setListContent(null,\"none\");\'><img src=\"resources/ui/listview.jpg\" height=\"32\" style='opacity:"+(this.szListContent=="none"?0.5:0.2)+";border:"+(this.szListContent=="none"?"#666 solid 1px":"0")+";'></a>";
		szHTML += "<a class=\"listitemcontrol\" title=\"cambia contenuto del elenco\" href=\'javascript:maptune.jsapi.setListContent(null,\"info\");\'><img src=\"resources/ui/articelview.jpg\" height=\"32\" style='opacity:"+(this.szListContent=="info"?0.5:0.2)+";border:"+(this.szListContent=="info"?"#666 solid 1px":"0")+";'></a>";
		szHTML += "<a class=\"listitemcontrol\" title=\"cambia contenuto del elenco\" href=\'javascript:maptune.jsapi.setListContent(null,\"gallery\");\'><img src=\"resources/ui/galleryview.jpg\" height=\"32\" style='opacity:"+(this.szListContent=="gallery"?0.5:0.2)+";border:"+(this.szListContent=="gallery"?"#666 solid 1px":"0")+";'></a>";
		szHTML += "<a class=\"listitemcontrol\" title=\"cambia contenuto del elenco\" href=\'javascript:maptune.jsapi.setListContent(null,\"hideall\");\'><img src=\"resources/ui/collapse.jpg\" height=\"32\" style='opacity:"+(this.szListContent=="gallery"?0.5:0.2)+";'></a>";
		szHTML += "<a class=\"listitemcontrol\" title=\"cambia contenuto del elenco\" href=\'javascript:maptune.jsapi.toggleLayerType(\"Collection\");\'><img src=\"resources/ui/black_star_u2605_icon_64x64.png\" height=\"32\" style='opacity:"+(maptune.jsapi.szLayerType=="Collection"?0.8:0.2)+";'></a>";
		szHTML += "<a href=\"javascript:javascript:maptune.jsapi.setMapContent(null,'show');\"><img src='resources/ui/checkbox_checked.gif' height='22' style=\"opacity:0.2;float:right;margin-right:11px;margin-top:5px\" /></a>";
		szHTML += "<a href=\"javascript:javascript:maptune.jsapi.setMapContent(null,'hide');\"><img src='resources/ui/box.gif' height='22' style=\"opacity:0.2;float:right;margin-right:11px;margin-top:5px\" /></a>";
		szHTML += "</div>";
		$("#sidebar-footer")[0].innerHTML = szHTML;
	}

    // debug !
	if (0){
		var errorDiv = document.getElementById("debug");
		if ( errorDiv ){
			errorDiv.innerHTML = "debug:";
			if ( this.timeline ){
				errorDiv.innerHTML = " timeline: ";
				errorDiv.innerHTML += new Date(this.timeline.firstTime).toDateString();
				errorDiv.innerHTML += " - ";
				errorDiv.innerHTML += new Date(this.timeline.lastTime).toDateString();
				errorDiv.innerHTML += " (";
				errorDiv.innerHTML += this.timeline.firstTime;
				errorDiv.innerHTML += " - ";
				errorDiv.innerHTML +=this.timeline.lastTime;
				errorDiv.innerHTML += ")";
			}
		}
	}

	if ( (maptune.jsapi.mapParam && maptune.jsapi.mapParam.footer) ){
		var szHTML = "";
		var listItem = document.createElement("div");
		listItem.setAttribute("style","padding-top:0.5em;border-top:#ddd solid 1px");
		$(maptune.jsapi.mapParam.footer).appendTo(listItem); 
		this.itemList.appendChild(listItem);
	}

};
/**
 * helper function to set attribute "unselectable" = "on"  
 * @return true or false
 */
function __makeUnselectable(node) {
	if ( node){
		if (node.nodeType == 1) {
			node.setAttribute("unselectable","on");
		}
		var child = node.firstChild;
		while (child) {
			__makeUnselectable(child);
			child = child.nextSibling;
		}
	}
}
/**
 * clear sidebar 
 * @return true or false
 */
MapUp.prototype.clearSidebar = function() {
	if ( !this.itemList ) {
		return;
	}
	this.lastSource = null;
	var list = this.itemList; 
	if ( list && list.hasChildNodes() )	{
		while ( list.childNodes.length >= 1 ) {
			list.removeChild( list.firstChild );       
		} 
	}
};
/**
 * clear legend 
 * @return true or false
 */
MapUp.prototype.clearLegend = function() {
	if ( !this.legendDiv ) {
		return;
	}
	this.iconlist = new Array(0);
	var list = this.legendDiv;
	if ( list.hasChildNodes() )	{
		while ( list.childNodes.length >= 1 ) {
			list.removeChild( list.firstChild );       
		} 
	}
};
/**
 * redraw overlay and sidebar
 * @return true or false
 */
maptune.MapUp.prototype.redraw = function() {
//	this.clearLayer();

	if ( this.timeline ){
		this.timeline.hideTimeWindow();
	}

	// make layer first, we need the marker in the sidebar items
	this.redrawLayer();

	// 2. draw sidebar items
	this.clearSidebar();
	this.drawSidebar();
};

/**
 * synchronize sidebar to map zoom and pan
 * @return true or false
 */
var __zoomToScale = new Array(
     591657550
    ,295828755
    ,147914387
     ,73957193
     ,36978596
     ,18489298
      ,9244649
      ,4622324
      ,2311162
      ,1155581
       ,577790
       ,288895
       ,144447
       ,72223
        ,36111
        ,18055
         ,9027
         ,4513
         ,2256
         ,1128);

MapUp.prototype.synchronize = function() {

	this.lastMapZoom = this.actualMapZoom;
	this.lastMapCenter = this.actualMapCenter;
	this.lastMapBounds = this.actualMapBounds;
	this.lastMapScale = this.actualMapScale;

	this.actualMapCenter = _map_getCenter(this.map);
	this.actualMapZoom = _map_getZoom(this.map);

	this.actualMapBounds = _map_getBounds();

	this.actualMapScale = __zoomToScale[this.actualMapZoom];

	// on zoom out do some resets 
	// --------------------------------
	if ( 0 && this.lastZoom && (this.lastZoom > this.actualMapZoom) ){
		for ( var i=0; i<this.layer.length; i++ ){
			this.layer[i].fNoSmall = false;
			this.clearOneLayer(this.layer[i]);
		}
	}
	this.lastZoom = this.actualMapZoom;
	// --------------------------------

	if ( !maptune.jsapi.fSidebarClick ){
		this.redrawLayer();
	}

	if ( this.fClipSidebarToMapExtent && !maptune.jsapi.fSidebarClick ){
		this.clearSidebar();
		this.drawSidebar();
		this.highlightSidebarItem(this.map,actualInfoMarker);
	}else{
		//this.highlightSidebarItem(this.map,actualInfoMarker);
		if ( maptune.jsapi.fSidebarClickZoom ){
			maptune.jsapi.fSidebarClickZoom = false;
		}else{
			maptune.jsapi.fSidebarClick = false;
		}
	}

	if ( fShowTooltips && (this.actualMapZoom >= 15) ){
		this.showTooltips(true);
	}else{
		this.showTooltips(false);
	}
	this.fSynchronized = true;
	this.fFixMarkerClipping = false;

	maptune.jsapi.fSidebarClick = false;

	try
	{
		maptune.jsapi.onSynchronize();	
	}
	catch (e)
	{
	}
};
/**
 * synchronize map after resize
 */
MapUp.prototype.checkResize = function(width,height) {
	_map_checkResize(this.map,width,height);
	maptune.jsapi.fixItemListTitles();

};

/*
 * parse the JSON data and create all layer overlays
 * loops through layer and sublayer and calls _mapup_makeLayer();
 * @param map the Google Maps API instance
 * @param layer JSON object of one layer
 * @param defaultIcon a default icon image for the marker
 */
MapUp.prototype.makeItemList = function(layerObj) {

	if ( maptune.jsapi.szLayerType ){
		var type = layerObj.parent.parent?layerObj.parent.parent.type:layerObj.parent.type;
		if ( !eval("type.match(/"+maptune.jsapi.szLayerType+"/)") ){
			return 0;
		}
	}
	if ( !this.itemList ) {
		return 0;
	}

	var layer		= layerObj.data;
	var defaultIcon = layerObj.defaultIcon;

	// get additional parameter for the layer
	var layerP = _mapup_getLayerParam(layer.properties.name);

	var markers = layer.features;
	if ( !markers ){
		markers = new Array(0);
	}

	// check visibility of all layer features and count them

	var fVisible = true;
	var nVisible = markers.length;
	if ( this.map ){
		fVisible = false;
		nVisible=0;
		for(var i=0; i < markers.length; i++) {
			if ( markers[i].fVisible ){
				nVisible++;
				fVisible = true;
			}
		}
	}

	if ( (layer.properties.legendstyle && layer.properties.legendstyle.match(/NOLEGEND/)) || layer.fNoLegend ){
		return 0;
	}
    var listItem = null;

	if ( 1 ){

		// data source header
		// --------------------

		if ( (this.lastSource != layer.source) ){

			listItem = document.createElement("li");
            listItem.setAttribute("class","listitem");

			szName = (layerObj.parent.title || layerObj.title || layer.source);
			layer.sourcelegend = (layer.sourcelegend || "expanded");

			var layerP = _mapup_getLayerParam(szName);
			szName = (layerP?layerP.title:null) || szName;

			var szHTML = "";

				szHTML += "<a style=\"float:left;margin-top:1.2em;margin-left:0.5em;\" href=\"javascript:maptune.jsapi.removeData('"+layer.source+"')\"><img src='resources/ui/delete.png' height='22' style=\"opacity:0.3;\" /></a>";

				if ( layer.sourcelegend == "collapsed" ){
					szHTML += "<a class=\"title collapsed\" href=\'javascript:maptune.jsapi.setListContent(\""+layer.source+"\",\"showall\");\'>";
					szHTML += szName;
					if ( layerObj.data && layerObj.data.properties && layerObj.data.properties.description ){
						szHTML += "<br/><span class=\"description\" >";
						szHTML += layerObj.data.properties.description;
						szHTML += "</span>";
					}
					szHTML += "</a>";
				}else{

					szHTML += "<a class=\"title expanded\" href=\'javascript:maptune.jsapi.setListContent(\""+layer.source+"\",\"hideall\");\'>";
					szHTML += szName;
					szHTML += "</a>";
					if ( layerP && layerP.description ){
						szHTML += "<p class='comment'>";
						szHTML += layerP.description;
						szHTML += "</p>";
					}
					if ( layerObj && layerObj.description ){
						szHTML += "<p class='comment'>";
						szHTML += layerObj.description;
						szHTML += "</p>";
					}
					if ( layerObj.parent && layerObj.parent.description ){
						szHTML += "<p class='comment'>";
						szHTML += layerObj.parent.description;
						szHTML += "</p>";
					}
					if ( layerObj.data && layerObj.data.properties && layerObj.data.properties.description ){
						szHTML += "<br/><span >";
						szHTML += layerObj.data.properties.description;
						szHTML += "</span>";
					}
					if ( layerObj.data && layerObj.data.properties && layerObj.data.properties.Snippet ){
						szHTML += "<br/><span >";
						szHTML += layerObj.data.properties.Snippet;
						szHTML += "</span>";
					}
				}



			listItem.innerHTML = szHTML;

			this.itemList.appendChild(listItem);
			this.lastSource = layer.source;
			this.lastSourceLegend = layer.sourcelegend;
		}
	}

	// if layer is part of a collapsed layer group, don't generate entries
	// -------------------------------------------------------------------
	if (1){
		if ( this.lastSourceLegend && (this.lastSourceLegend == "collapsed") ){
			return 1;
		}
	}
    
	// create layer header
	// --------------------

	if ( 1 ){

		listItem = document.createElement("li");
		listItem.setAttribute("class","listheader");

		listItem.innerHTML =  "";

		// 1. button to load, show, hide, expand ...
		// ------------------------------------------	
		// only if layer is sublayer
		if ( (layer.properties.name != layer.source)){
			// layer not loaded, add button to load
			if ( layer.link ){
				var szLayer = layer.link.properties.href.split(".js")[0];
				var szLayerSource = __getUrlRoot(layerObj.url) + layer.link.properties.href + (layerObj.url.match(/.gz/)?".gz":"");
				listItem.innerHTML +=  "<span style=\"margin-left:0px;\"></pan>";
				listItem.innerHTML += "<a class=\"listitemname\" href=\'javascript:maptune.szMasterSource=\""+layer.source+"\";maptune.szLinkLayer=\""+layer.properties.name+"\";maptune.jsapi.addData(\""+szLayer+"\",\"\",\""+szLayerSource+"\");\'><img src='resources/ui/box.gif' height='22' style=\"vertical-align:-10px\" /></a>" ;
			}		
			else
			// layer loaded, add button to show/hide
			if ( markers.length){
				if ( layer.legend == "collapsed" ){
					listItem.innerHTML +=  "<a class=\"listitemname\" href=\'javascript:maptune.jsapi.setListContent(\""+layer.properties.name+"\",\"show\");\'><img src='resources/ui/plusbox2.gif' height='22' style=\"vertical-align:-10px\" /></a>" ;
				}else{
					listItem.innerHTML +=  "<a class=\"listitemname\" href=\'javascript:maptune.jsapi.setListContent(\""+layer.properties.name+"\",\"hide\");\'><img src='resources/ui/minusbox2.gif' height='22' style=\"vertical-align:-10px\" /></a>" ;
				}
				if ( maptune.jsapi.fCheckLayer || (layer.properties.legendstyle && layer.properties.legendstyle.match(/CHECKSUBLAYER/))){
					if ( layer.properties.visibility == "0" ){
						listItem.innerHTML += "<a class=\"listitemname\" href=\'javascript:maptune.jsapi.setMapContent(\""+layer.properties.name+"\",\"show\");\'><img src='resources/ui/box.gif' height='22' style=\"float:right;margin-right:10px;vertical-align:-5px\" /></a>" ;
					}else{
						listItem.innerHTML += "<a class=\"listitemname\" href=\'javascript:maptune.jsapi.setMapContent(\""+layer.properties.name+"\",\"hide\");\'><img src='resources/ui/checkbox_checked.gif' height='22' style=\"float:right;margin-right:10px;vertical-align:-5px\" /></a>" ;
					}
				}
			}
		}

		// 2. layer description
		// ------------------------------------------	
		if ( layer.link ){
			// layer not loaded
			//
			listItem.innerHTML += "&nbsp;";
			listItem.innerHTML += "<span class=\"listitemname\" style=\"color:#bbbbbb\">"+layer.properties.name+"</span>";
			// listItem.innerHTML += "<br/><span class=\"listitemcontrolindent\"></span> ";
			// listItem.innerHTML += "<a class=\"listitemcontrol\" title=\"zoom fin che visibile\" href=\"javascript:maptune.jsapi.changeZoomToScale("+layerObj.upper+");\" style=\"color:#bbbbbb\">(not loaded)</a>";
		}else

		if ( !markers.length ){
			// if layer is only title, has name and more than 1 sublayer > generate collapse entry
			// -----------------------------------------------------------------------------------
			if ( 0 && layer.properties.name && layer.properties.name.length && layer.layers && (layer.layers.length > 1) ){
				// layer only title
				//
				if ( layer.legend == "collapsed" ){
					listItem.innerHTML +=  "<a class=\"listitemname\" href=\'javascript:maptune.jsapi.setListContent(\""+layer.properties.name+"\",\"show\");\'><img src='resources/ui/plusbox2.gif' height='22' style=\"margin-left:0px;margin-right:5px;\" /></a>" ;
				}else{
					listItem.innerHTML +=  "<a class=\"listitemname\" href=\'javascript:maptune.jsapi.setListContent(\""+layer.properties.name+"\",\"hide\");\'><img src='resources/ui/minusbox2.gif' width='22' style=\"margin-left:0px;margin-right:5px;\" /></a>" ;
				}
				if ( layer.properties.name != layer.source ){
					listItem.innerHTML += "<span class=\"listitemname\" style=\"font-weight:bold;color:#ccc\">"+layer.properties.name+"</span>";
				}
			}
		}else

		if ( 0 && layerObj.upper && (layerObj.upper < this.actualMapScale) && !layer.fOverrideScaleDependency){
			// layer not visible because out of scale
			// --------------------------------------
			listItem.innerHTML += "&nbsp;";
			listItem.innerHTML += "<span class=\"listitemname\" style=\"color:#bbbbbb\">"+layer.properties.name+"</span>";
			if ( !(layer.legend == "collapsed") ){
				listItem.innerHTML += "<br/><span class=\"listitemcontrolindent\"></span> ";
				listItem.innerHTML += "<a class=\"listitemcontrol\" title=\"zoom fin che visibile\" href=\"javascript:maptune.jsapi.changeZoomToScale("+layerObj.upper+");\" style=\"color:#bbbbbb\">(non visibile a questo livello zoom)</a>";
				listItem.innerHTML += "<a class=\"listitemcontrol\" title=\"zoom fin che visibile\" href=\'javascript:maptune.jsapi.setListContent(\""+layer.properties.name+"\",\"overridescaledependency\");\' style=\"color:#bbbbbb\"> show</a>";
			}
		}else{
			// layer visible
			// ---------------------------------------
			if ( (layer.properties.name != layer.source) ){
				listItem.innerHTML += "<span class=\"listitemname\">"+layer.properties.name+"</span>";
			}
			if ( (layer.fUseListStateButtons || (layer.parent && layer.parent.fUseListStateButtons )) && (layer.legend !== "collapsed") ){
				var szHTML = "";
				szHTML += "<div class=\"listitemcontrolgroup\" >";
				szHTML += "<a class=\"listitemcontrol\" style=\"float:left\" title=\"cambia contenuto del elenco\" href=\'javascript:maptune.jsapi.setListContent(\""+layer.properties.name+"\",\"none\");\'><img src=\"resources/ui/listview.jpg\" height=\"32\" style='opacity:"+(!layer.fShowInfoInList&&!layer.properties.fGallery?0.2:0.2)+";border:"+(!layer.fShowInfoInList&&!layer.properties.fGallery?"#666 solid 1px":"0")+";'></a>";
				szHTML += "<a class=\"listitemcontrol\" style=\"float:left\" title=\"cambia contenuto del elenco\" href=\'javascript:maptune.jsapi.setListContent(\""+layer.properties.name+"\",\"info\");\'><img src=\"resources/ui/articelview.jpg\" height=\"32\" style='opacity:"+(layer.fShowInfoInList?0.2:0.2)+";border:"+(layer.fShowInfoInList?"#666 solid 1px":"0")+";'></a>";
				szHTML += "<a class=\"listitemcontrol\" style=\"float:left\" title=\"cambia contenuto del elenco\" href=\'javascript:maptune.jsapi.setListContent(\""+layer.properties.name+"\",\"gallery\");\'><img src=\"resources/ui/galleryview.jpg\" height=\"32\" style='opacity:"+(layer.properties.fGallery?0.2:0.2)+";border:"+(layer.properties.fGallery?"#666 solid 1px":"0")+";'></a>";

				var szId    = (layer.properties.name);
				var szValue = this.szSearchStringA[String(szId)];
				szValue = (typeof(szValue) != "undefined")?szValue:"";
				if ( layer.fLayerSpecificFilter ){
					szHTML += "<div "
							  +"class=\"itemlist-filterform\" "
							  +"name=\"IndicatorFilterForm"+layer.properties.name+"\">" 
								+"<form id=\"IndicatorFilterFormH\" name=\"IndicatorFilterFormH\" action=\"javascript:maptune.jsapi.search();\"> "
								  +"<input id=\"query-inline\" placeholder=\"filter\" title=\"define filter\" "	
									+"style=\"width:150px;height:22px;position:relative;top:0px;border:none\" title=\"query map items\" " 
									+"onkeyup=\"javascript:var value = $(this).val();maptune.jsapi.search('"+layer.properties.name+"',value);\" "
									+"onsubmit=\"javascript:return false;\" value=\""+szValue+"\">"
								+"</form>" 
							  +"</div>";
				}
				szHTML += "<a href=\"javascript:maptune.jsapi.removeData('"+layer.source+"')\"><img src='resources/ui/delete.png' height='22' style=\"opacity:0.3;float:right;margin-right:11px;margin-top:7px\" /></a>";

				szHTML += "<span class=\"listitemname\" style=\"opacity:0.4;float:right;margin-right:11px;margin-top:8px\">"+layer.properties.name+"</span>";
				
				szHTML += "</div>";
				szHTML += "<div style=\"clear:both\"></div>";
				listItem.innerHTML += szHTML;
			}
		}

		layer.properties.listItem = this.itemList.appendChild(listItem);
	}

	if ( !markers || markers.length === 0 ){
		if ( !layer.properties.listItem ){ 
			var listItem = document.createElement("div");
			listItem.setAttribute("style","text-align:center");
			$("<span>(nessun elemento)</span>").appendTo(listItem); 
			this.itemList.appendChild(listItem);
		}
		return 1;
	}
	if ( 0 && (__getType(markers[0]) !== "Point") && (__getType(markers[0]) !== "Polygon") ){
		return 1;
	}
	if ( layer.legend == "collapsed" ){
		return 1;
	}

	// create en entry for all items of layer
	//
	var nItems = null;
	if ( layer.properties.fGallery && !layer.fShowInfoInList ){
		nItems = this.makeItemListGallery(layerObj,defaultIcon,markers);	
	}else{
		nItems = this.makeItemListItems(layerObj,defaultIcon,markers);
	}
	// GR 10.06.2013 if we have no marker, remove evt.generated "listitemcontrol"
	if ( (typeof(nItems) != 'undefined') && (nItems === 0) && 
		 (typeof(this.szSearchStringA[String(layer.properties.name)]) == "undefined") ){
		var xA = layer.properties.listItem.getElementsByTagName("div");
		if (xA.item(0)){
			xA.item(0).parentNode.removeChild(xA.item(0));
		}
	}

	// reset immediately
	layer.fShowAll = false;

	// switch off parts by css
	// hide all elements of class (layerP.nolistClass) inside element with id "itemlist"
	//
	if ( layerP && layerP.nolistClass ){
		$("#itemlist ."+layerP.nolistClass).css("display","none");
	}

	// GR 22.05.2012 try to keep header fixed on scrolling
	//
	if ( this.fScrollFixListHeader ){ 
		$('#itemlist').scroll( function() {
			maptune.jsapi.fixItemListTitles();
		});
		$(window).scroll( function() {
			maptune.jsapi.fixItemListTitles();
		});
		maptune.jsapi.fixItemListTitles();
	}

	this.highlightSidebarItem(this.map,actualInfoMarker);
	requestInfoMarker = null;

	// GR 11.12.2012 workaround for touch devices to get touchstart on listitems
	//
	if ( this.isTouch ){

		maptune.touchScroll("itemlist");

		// jquery mobile specific
		// GR 22.11.2014 must be with try 	
		//
		try {
			$(".listitem").live("touchstart", function() {
			  $(this).addClass("touchactive");
			}).live("touchmove", function() {
			  $(this).removeClass("touchactive");
			}).live("touchend", function() {
			  $(this).removeClass("touchactive");
			});
		}catch (e){}
	}

	// GR 26.09.2016 make all images clickable
	//
	maptune.clickableImages("itemlist");

	return 1;
};

MapUp.prototype.fixItemListTitles = function() { 
	// GR 22.05.2012 try tpo keep header fixed on scrolling

	if ( !this.fScrollFixListHeader ){
		return;
	}
	var p = $('#itemlist').scrollTop();
	var nCount = 0;

	$(".listheader").each(function(){
		nCount++;
	});
	$(".listheader").each(function(){

		var offset = $('#itemlist').offset();
		var width  = $('#itemlist').width();
		var o = this.oldTop?this.oldTop:this.offsetTop;
		this.oldTop = o;
		// if header is scrolled outside on top; fix it to top
		//
		if ( p && (p+$(window)[0].pageYOffset+150 > o)  ){
			this.style['position'] = 'fixed'; 
			this.style['background'] = '#fff';
			this.style['width'] = (width) + 'px';
			this.style['top'] = (offset.top-$(window)[0].pageYOffset-3)+'px';
			//this.style['margin-left'] = '-14px';
			this.style['padding-top'] = '0.5em';
			this.style['padding-bottom'] = '0.5em';
			this.style['z-index'] = '1';
			//this.style['border-bottom'] = '1px solid #ddd';
			this.style['box-shadow'] = '0px 0px 7px 0px #ccc';
			this.nextSibling.style['margin-top'] = (this.offsetHeight+11) +"px";
		}else{
			if ( this.style['position'] == 'fixed' ){
				this.style['position'] = 'static';
				this.style['top'] = '';
				this.style['margin-left'] = '';
				this.style['padding-top'] = '';
				this.style['padding-bottom'] = '';
				this.style['width'] = '';
				this.style['border'] = '0';
				this.style['box-shadow'] = null;
				this.nextSibling.style['margin-top'] = '3px';
			}
		}
	});
//	this.highlightSidebarItem(this.map,actualInfoMarker);
	requestInfoMarker = null;
};


/*
 * parse the JSON data and create the items in the itemlist in thesidebar
 * @param layer JSON object of one layer
 * @param defaultIcon a default icon image for the marker
 */
MapUp.prototype.makeItemListItems = function(layerObj,defaultIcon,markers) {

	if ( !this.itemList ) {
		return;
	}
	if ( !markers || markers.length === 0 ){
		return;
	}
	if ( 0 && (__getType(markers[0]) !== "Point") && (__getType(markers[0]) !== "Polygon") ){
		return;
	}

	var layer = layerObj.data;

	if ( layer.legend == "collapsed" ){
		return;
	}

	// create en entry for all items of layer

	var listTable = document.createElement("div");
	listTable.setAttribute("class","listtable");

	this.itemList.appendChild(listTable);

	if ( fShowLinkInList ){
		document.getElementById("sidebar").style.left = "0px";
		document.getElementById("sidebar").style.width = "800px";
		document.getElementById("sidebar").style.height = "800px";
		document.getElementById("legend").style.visibility = "hidden";
		document.getElementById("map").style.visibility = "hidden";
	}

	var maxItems = (maptune.jsapi.mapParam && maptune.jsapi.mapParam.maxitems)?maptune.jsapi.mapParam.maxitems:250;
	var nItems = 0;
	var szLastDate = "";
    var listItem = null;
	
	if ( (_mapup_explDate === "") && this.timeline && layer.duration ){
		var d = new Date(Number(this.timeline.lastTime));
		_mapup_explDate = szDayA[(d.getDay())] + " " + d.getDate()+" " +szMonthA[(d.getMonth())]+ " " +d.getFullYear();
	}
	if ( layer.fShowAll ){
		listItem = document.createElement("div");
		listItem.setAttribute("class","listitem filterhint");
		$("<a href=\'javascript:maptune.jsapi.setListContent(\""+layer.properties.name+"\",\"clip\");\' >&nbsp;nascondi elementi fuori quadro</a>").appendTo(listItem); 
		listTable.appendChild(listItem);
	}

	// make a list element for every feature of the layer
	// clip list to maxItems

	for(var i=0; (i < markers.length) && (nItems < maxItems); i++) {

		// get icon object 
		var icon = _mapup_getIcon(this.map,defaultIcon,layer,markers,i,'normal');
		var myIcon = icon.image;
			myIcon = icon.legendimage?icon.legendimage:myIcon;

        var fVisible = false;
		if ( this.map && (this.fClipSidebarToMapExtent && !layer.fShowAll) ){

			fVisible = markers[i].fVisible;

			if ( markers[i].gOverlayObject && ((markers[i].gOverlayObject == actualInfoMarker)) ){
				fVisible = true;
			}
		}
		else
		if ( this.isQuery() && !this.isMarkerInSearchQuery(layerObj,markers[i]) ){
			fVisible = false;
		}
		else
		if ( !this.isMarkerInFilter(layerObj,markers[i]) ){
			fVisible = false;
		}
		else {
			fVisible = true;
		}

		if ( fVisible || (this.fFixMarkerClipping && markers[i].inLegend) ){
			markers[i].inLegend = true;
		}else{
			markers[i].inLegend = false;
		}

		if ( markers[i].inLegend && !markers[i].fSuppressInfo ){

			var fShowInfoInList = (layer.fShowInfoInList || ( (markers[i].gOverlayObject && (markers[i].gOverlayObject == actualInfoMarker)) && !markers[i].fInfo) );
			
			markers[i].fInfo = fShowInfoInList;

			// make click handler
			// 
			var handler = null;
			if ( this.map ){
				if ( markers[i].gOverlayObject && !markers[i].fSuppressInfo ){
					// if item visible, opem info window
					handler = _mapup_createMarkerClickHandlerGoto(this.map, markers[i].gOverlayObject, layerObj, markers[i], layer.fShowInfoInList?"small":"normal", i);
				}else{
					// if item outside, goto 
					handler = _mapup_createGoToHandler(this.map, markers[i]);
				}
			}

			// create item
			// ----------------------------------------------------

			nItems++;

			// if list mode with complete info 
			// make date header, if date changed
			// 
			if ( layer.fShowInfoInList && markers[i].properties.utime ){

				// show dates, if layer with timeline and new date range 
				// --------------------------------------------------------------
				var d = new Date(Number(markers[i].properties.utime));
				var szDate = szDayA[(d.getDay())] + " " + d.getDate()+" " +szMonthA[(d.getMonth())]+ " " +d.getFullYear();
				var szDateEnd = "";
				if ( markers[i].properties.utimeEnd ){
					d = new Date(Number(markers[i].properties.utimeEnd));
					szDateEnd = szDayA[(d.getDay())] + " " + d.getDate()+" " +szMonthA[(d.getMonth())]+ " " +d.getFullYear();
				}

				if ( this.timeline && layer.duration && (szDate != szLastDate) ){
					var dateItem = document.createElement("p");
					dateItem.setAttribute("class","itemlist-datum-header");

                    var szPiu = "";
					/**
                    if ( szDate == _mapup_explDate ){
						szPiu = " <a href=\"javascript:_mapup_open_sidebar_datesection('')\" style=\"font-size:0.8em;\">";
					}else{
						szPiu = " <a href=\"javascript:_mapup_open_sidebar_datesection('"+szDate+"')\" style=\"font-size:0.8em;\">";
					}
					**/
					dateItem.innerHTML = szPiu + szDate + ((szDateEnd != szDate)?(" - "+szDateEnd):""); 
					listTable.appendChild(dateItem);
					szLastDate = szDate;
				}
			}

			// make item
			// ----------------

			var nOpacity = (markers[i].gOverlayObject)?1:0.3;

			listItem = document.createElement("div");
			listItem.setAttribute("class","listitem");
            
			var szRowContent = "";

			// make all a button
			// -----------------
			szRowContent += "<a href=\"javascript:void(0);\">";

			// a) listitem - left part
			// =======================
			//
			szRowContent += "<div class=\"listitem-left\" >";

			//szRowContent += "<a href=\"javascript:void(0);\">";
			if ( __getType(markers[i]) == "LineString" ){
				szRowContent += "<font weight=\"bold\" color=\""+markers[i].properties.style.lineStyle.color+"\">&#x25AC;</font> ";
			}
			else if ( __getType(markers[i]) == "Polygon" ){
				szRowContent += "<font weight=\"bold\" size=\"5px\" color=\""+markers[i].properties.style.fillStyle.color+"\">&#x25A0;</font> ";
			}
			else{
				var scale  = ($('#itemlist').width()<500)?0.8:1;
				szRowContent += "<div class='itemlist-icon'><img src=\""+myIcon+"\" height=\""+(icon.iconSize[1]*scale)+"\" style=\"opacity:"+nOpacity+"\" /></div>";
			}

			szRowContent += "</div>";

			//
			// ----------------------


			// b) listitem - right part
			// ========================
			//

			szRowContent += "<div class=\"listitem-right\" ><div class=\"item\" >";

			// if list mode compact -  show image, if parametrized
			// ----------------------------------------------------
			if ( !fShowInfoInList && (maptune.jsapi.mapParam && maptune.jsapi.mapParam.all && maptune.jsapi.mapParam.all.oneLineKeepImage) ){
				var match = markers[i].properties.description.match(/src=(?:\"|\')?([^>]*[^/].(?:jpg|jpeg|bmp|gif|png))(?:\"|\')?/i);
				var szImg = (match && (match.length>1))?(match[1]):"";
				if ( szImg ){
					szRowContent += "<img src='" + szImg + "' height='30' style='margin-right:3px' />";
					szRowContent += "</div></div>";
				}
			}

			// if list mode compact -  'one line' - item info and timeline
			// -----------------------------------------------------------
			if ( !layer.fShowInfoInList && this.timeline && layer.duration && markers[i].properties.utime ){

				// show dates, if layer with timeline
				// --------------------------------------------------------------
				var d = new Date(Number(markers[i].properties.utime));
				var szDate = d.getDate()+" " +szMonthA[(d.getMonth())]+ " " +d.getFullYear();
				var szDateEnd = "";
				if ( markers[i].properties.utimeEnd ){
					d = new Date(Number(markers[i].properties.utimeEnd));
					szDateEnd = d.getDate()+" " +szMonthA[(d.getMonth())]+ " " +d.getFullYear();
				}

				//var dateItem = document.createElement("div");
				//dateItem.setAttribute("class","font-family:arial;font-size:0.8em;color:#53637D;margin-left:4px;margin-top:5px;margin-bottom:0px;");

				var szQualify = this.getMarkerInTimeLapQualify(markers[i]);
				switch ( szQualify ){
					case "past":
						szQualify = "<span style='color:#ddd;font-size:1.2em;'> - passato</span>";
						break;
					case "present":
						szQualify = "<span style='color:#66dd66;font-size:1.2em;'> - oggi !</span>";
						break;
					case "future":
						szQualify = "<span style='color:#eecc22;font-size:1.2em;'> - futuro</span>";
						break;
				}
				szRowContent += "<div class='itemlist-date'>";
				szRowContent += szDate + ((szDateEnd!=szDate)?(" - "+szDateEnd):"") + szQualify;
				szRowContent += "</div>";
			}

			// make regular right part
			// ------------------------------------------------------------------------------

			var szTitle = markers[i].properties.name;

			var layerP = _mapup_getLayerParam(layer.properties.name);
			if ( layerP && layerP.titlePath ){
				szTitle = _mapup_getTitleByPath(markers[i],layerP.titlePath);
			}
			try	{
				szTitle = maptune.jsapi.onInfoWindowTitle(szTitle,markers[i]);
			}
			catch (e){}

			szTitle = szTitle||"&nbsp;";

			if ( fShowInfoInList ){
				szRowContent += szTitle;
			}else{
				szRowContent += "<div class=\"listitem-right-title\">"+szTitle+"</div>";

				if ( !markers[i].gOverlayObject) {
					szRowContent += "&nbsp;  <a class=\"listitem-right-zoomto noprint\" title=\"mostra punto ingrandito\" href=\'#\'><img src='resources/ui/zoomto.png' /></a>" ;
					if ( fFullScreen ){
						szRowContent += "<p></p>";
					}
				}
			}

			if ( fShowInfoInList && !markers[i].fSuppressInfo ){

				var	szDesc = markers[i].properties.description || "";
				// user defined info window content			
				try	{
					szDesc = maptune.jsapi.onOpenInfoWindow(markers[i].properties.description,markers[i],"sidebar");
				}
				catch (e){}
				if ( szDesc && szDesc.length ){
					szRowContent += "<div class=\"framed description\" >"+szDesc+"</div>";
				}

				if (this.fCollectItems || (maptune.jsapi.mapParam && maptune.jsapi.mapParam.all && maptune.jsapi.mapParam.all.fCollectItems) ){
					if ( layerObj.name == "Collection" ){
						szRowContent += "<a href=\"#\" onclick=\"event.stopPropagation();_mapup_remove_item('"+layerObj.source+"','"+layerObj.name+"',"+i+")\" >"+"remove "+"</a>";
						szRowContent += "<a href=\"#\" onclick=\"event.stopPropagation();_mapup_remove_item('"+layerObj.source+"','"+layerObj.name+"',"+i+")\" >&#x2605;</a>";
					}else{
						szRowContent += "<a href=\"#\" onclick=\"event.stopPropagation();_mapup_collect_item('"+layerObj.source+"','"+layerObj.name+"',"+i+")\" >"+"collect "+"</a>";
						szRowContent += "<a href=\"#\" onclick=\"event.stopPropagation();_mapup_collect_item('"+layerObj.source+"','"+layerObj.name+"',"+i+")\" >&#x2605;</a>";
					}
				}
			}
			else if ( markers[i].properties.data ){
				// to redesign
				if ( markers[i].properties.data.INDIRIZZO ){
					szRowContent += "<span style=\"color:#888888\">"+markers[i].properties.data.INDIRIZZO+"</span>";
				}
				if ( markers[i].properties.data.TELEFONO ){
					szRowContent += "<span style=\"color:#888888\">, tel:"+markers[i].properties.data.TELEFONO+"</span>"; 
				}
				if ( 0 && markers[i].properties.data.SITO ){
					szRowContent += " - "+"<a href=\'javascript:maptune.jsapi.openlink(\""+markers[i].properties.data.SITO+"\");\' >"+markers[i].properties.data.SITO+ "</a>" ; 
				}
				if ( 0 && markers[i].properties.data.LNK_1 ){
					var szMp3A = markers[i].properties.data.LNK_1.split("/");
					szRowContent += "<span class=\"noprint\"> - "+"<a class=\"noprint\" title=\'altre informazioni\' target=\'_blank\' href=\'"+markers[i].properties.data.LNK_1+"\' >altre informazioni</a></span>" ; 
				}
				if ( 0 && markers[i].properties.data.LNK_2 ){
					var szMp3A = markers[i].properties.data.LNK_2.split("/");
					szMp3A[szMp3A.length-1] = "[audio]";
					szMp3A[szMp3A.length-1] = "[mp3]";
					szRowContent += "<span class=\"noprint\"> - "+"<a class=\"noprint\" title=\'ascolti audio\' href=\'javascript:maptune.jsapi.playaudio(\""+markers[i].properties.data.LNK_2+"\");\' >" + szMp3A[szMp3A.length-1] + "</a></span>" ; 
				}

			}

			if ( fShowLinkInList &&  markers[i].properties.data && markers[i].properties.data.LNK_1 ){
				szRowContent += "<iframe align=\"left\" src =\""+markers[i].properties.data.LNK_1+"\" width=\"720\" height=\"600\" />";
			}

			// finish right part
			// ------------------------------------------------------------------------------
            szRowContent += "</div>";

			// finish 'all is button' 
			// ------------------------------------------------------------------------------
			szRowContent += "</a>";


			// finally make list item 
			// ------------------------------------------------------------------------------
			$(szRowContent).appendTo(listItem); 
			// ------------------------------------------------------------------------------

			if ( (typeof(handler) != "undefined") && handler ){
				listItem.onclick = handler;
			}
			listTable.appendChild(listItem);

			if ( this.fSidebarTooltips && this.map && markers[i].gOverlayObject ){
				markers[i].gOverlayObject.listItem = listItem;
				_map_createMyTooltipListener(listItem, markers[i].gOverlayObject);
			}
		}
	}
	// if more items than limit, make notice
	if ( nItems >= maxItems ){
		listItem = document.createElement("div");
		listItem.setAttribute("class","listitem filterhint");
		$("<a>&nbsp;&nbsp;lista troncata: "+(maxItems)+" di "+markers.length+" elementi elencati</a>").appendTo(listItem); 
		listTable.appendChild(listItem);
	}
	else if ( nItems < markers.length ){
		listItem = document.createElement("div");
		listItem.setAttribute("class","listitem filterhint");

		if ( nItems > 10 ){
			$("<span>&nbsp;"+(nItems)+"</span> elementi nella lista<br>").appendTo(listItem); 
		}

		if ( layerObj.nMarkerOutOfTime ){
			$("<a href=\'javascript:maptune.jsapi.setListContent(\""+layer.properties.name+"\",\"piu\");\' >&nbsp;+ "+(layerObj.nMarkerOutOfTime)+" elementi fuori tempo</a><br>").appendTo(listItem); 
		}
		if ( layerObj.nMarkerFiltered  ){
			$("<span>&nbsp;+ "+(layerObj.nMarkerFiltered+layerObj.nMarkerOutOfTime)+" elementi filtrati</span><br>").appendTo(listItem); 
		}
		var nMarkerOutside = markers.length - nItems - (layerObj.nMarkerFiltered+layerObj.nMarkerOutOfTime);
		if ( nMarkerOutside ){
			$("<a href=\'javascript:maptune.jsapi.setListContent(\""+layer.properties.name+"\",\"piu\");\' >&nbsp;+ "+(nMarkerOutside)+" elementi fuori quadro<img src='resources/ui/zoomto.png' style='margin-left:10px;vertical-align:-2px;height:14px'/></a>").appendTo(listItem); 
		}

		$("<hr>&nbsp;totale: "+(markers.length)+"<br>").appendTo(listItem); 

		listTable.appendChild(listItem);
	}
	return nItems;
};

var	_mapup_explDate = "";
_mapup_open_sidebar_datesection = function(szDate){
	_mapup_explDate = szDate;
	_mapUp.clearMap();
	_mapUp.redraw();
};


/* ...................................................................* 
 *  handle user collection requests                                   * 
 * ...................................................................*/ 

/*
 * copy item into the user collection layer
 * ask user to confirm
 * @param szSourceName the name of the layer source (if layer is sublayer)
 * @param szLayerName the name of the layer
 * @param nItem JSON the index of the item to copy 
 */
_mapup_collect_item = function(szSourceName,szLayerName,nItem){

	var	target = _mapUp.getLayer("*","Collection");
	maptune.confirmMessage("add to: '"+target.title+"' ?",function(){
		_mapup_do_collect_item(szSourceName,szLayerName,nItem);
	});
};

/*
 * execute copy into the user collection layer
 * update local storage collection object
 * @param szSourceName the name of the layer source (if layer is sublayer)
 * @param szLayerName the name of the layer
 * @param nItem JSON the index of the item to copy 
 */
_mapup_do_collect_item = function(szSourceName,szLayerName,nItem){
	layer = _mapUp.getLayer(szSourceName,szLayerName);
	if ( layer ){

		// copy item into collection
		var target = _mapUp.getLayer("*","Collection");
		var icon = layer.data.features[nItem].gOverlayObject.getIcon();
		icon = _mapup_getIcon(_mapUp.map,_mapup_szDefaultMarker,layer.data,layer.data.features,nItem,"");
		if ( icon ){
			layer.data.features[nItem].properties.icon = icon.image;
			layer.data.features[nItem].properties.smallicon = null;
		}
		target.data.features.push(layer.data.features[nItem]);

		// inform user
		maptune.infoMessage("added to: '"+target.title+"'");

		// update local storage
		var x = new Theme(target.data);
		var szJson = x.getPrettyString();
		maptune.storeObject("maptune-collection", szJson);
	}	
};
/*
 * remove item from user collection layer
 * update local storage collection object
 * @param szSourceName the name of the layer source (if layer is sublayer)
 * @param szLayerName the name of the layer
 * @param nItem JSON the index of the item to copy 
 */
_mapup_remove_item = function(szSourceName,szLayerName,nItem){
	layer = _mapUp.getLayer(szSourceName,szLayerName);
	if ( layer ){

		// remove item from map
		_mapUp.clearOneObject(layer.data.features[i]);

		// remove item from collection
		layer.data.features.splice(nItem, 1);
		_mapUp.redraw();

		// update local storage
		var x = new Theme(target.data);
		var szJson = x.getPrettyString();
		maptune.storeObject("maptune-collection", szJson);
	}	
};
/*
 * get collection object from local storage, and update collection layer
 * @param szSourceName the name of the layer source (if layer is sublayer)
 * @param szLayerName the name of the layer
 * @param nItem JSON the index of the item to copy 
 */
_mapup_get_collected_items = function(count){

	count = count || 0;
	// get collection from local storage
	var collection = maptune.getStoredObject("maptune-collection");
	if ( collection && (typeof(collection) == "object") ){
		// find collection layer, and set collection
		target = _mapUp.getLayer("*","Collection");
		if ( target ){
			target.data = collection;
		}else{
			if ( ++count < 5 ){
				setTimeout("_mapup_get_collected_items("+(count)+")",1000);
			}
		}
	}else
		if ( collection && (typeof(collection) == "string") ){
		maptune.infoMessage("error in collection",1000);
	}
};



/*
 * parse the JSON data and create the items in the itemlist in thesidebar
 * @param layer JSON object of one layer
 * @param defaultIcon a default icon image for the marker
 */
MapUp.prototype.makeItemListGallery = function(layerObj,defaultIcon,markers) {

	if ( !this.itemList ) {
		return;
	}
	if ( !markers || markers.length === 0 ){
		return;
	}
	if ( (__getType(markers[0]) !== "Point") && (__getType(markers[0]) !== "Polygon") ){
		return;
	}
	if ( layerObj.legend == "collapsed" ){
		return;
	}

	var layer = layerObj.data;

	// create en entry for all items of layer

	var listDiv = document.createElement("div");
	listDiv.setAttribute("class","listdiv");

	var listRow = document.createElement("div");
	listRow.setAttribute("class","row");

	var maxItems = 2000;
	var nItems = 0;
	var szLastDate = "";
	
	if ( (_mapup_explDate === "") && this.timeline && layer.duration ){
		var d = new Date(Number(this.timeline.lastTime));
		_mapup_explDate = szDayA[(d.getDay())] + " " + d.getDate()+" " +szMonthA[(d.getMonth())]+ " " +d.getFullYear();
	}

	for(var i=0; i < markers.length && (nItems < maxItems); i++) {

		// get icon object 
		var icon = _mapup_getIcon(this.map,defaultIcon,layer,markers,i);
		var myIcon = icon.image;
			myIcon = icon.legendimage?icon.legendimage:myIcon;

        var fVisible = false;
        var fActual = false;
		if ( this.map && this.fClipSidebarToMapExtent && !layer.fShowAll ){
			fVisible = markers[i].fVisible;
			if ( markers[i].gOverlayObject && ((markers[i].gOverlayObject == actualInfoMarker)) ){
				fVisible = true;
				fActual = true;
			}
		}
		else {
			fVisible = true;
		}
		if ( fVisible || (this.fFixMarkerClipping && markers[i].inLegend) ){
			markers[i].inLegend = true;
		}else{
			markers[i].inLegend = false;
		}
		if ( markers[i].inLegend && !markers[i].fSuppressInfo ){

			// make click handler
			// 
			var handler = null;
			if ( this.map ){
				if ( markers[i].gOverlayObject ){
					// if item visible, open info window
					handler = _mapup_createMarkerClickHandlerGoto(this.map, markers[i].gOverlayObject, layerObj, markers[i], "normal", i);
				}else{
					// if item outside, goto 
					handler = _mapup_createGoToHandler(this.map, markers[i]);
				}
			}

			// create item
			// ----------------------------------------------------

			nItems++;

			var d = new Date(Number(markers[i].properties.utime));
			// var szDate = d.toDateString();
			var szDate = szDayA[(d.getDay())] + " " + d.getDate()+" " +szMonthA[(d.getMonth())]+ " " +d.getFullYear();

			if ( this.timeline && layer.duration && (szDate != szLastDate) ){
				var dateItem = document.createElement("div");
				dateItem.setAttribute("class","col-sm-12 row-space-2 col-md-12");
				dateItem.setAttribute("style","font-family:arial;font-size:0.8em;color:#53637D;margin-top:2em;margin-bottom:2px;border-bottom:solid 1px #ddd");
                var szPiu = "";
                if ( szDate == _mapup_explDate ){
					szPiu = " <a href=\"javascript:_mapup_open_sidebar_datesection('')\" style=\"font-size:0.8em;\">";
				}else{
					szPiu = " <a href=\"javascript:_mapup_open_sidebar_datesection('"+szDate+"')\" style=\"font-size:0.8em;\">";
				}

				dateItem.innerHTML = szPiu + szDate + "</a>";

				listDiv.appendChild(listRow);

				listRow = document.createElement("div");
				listRow.setAttribute("class","row");
				listRow.appendChild(dateItem);

				szLastDate = szDate;
			}
			
			var listItem = document.createElement("div");
			listItem.setAttribute("class","col-sm-12 row-space-2 col-md-6");
			listItem.setAttribute("style","overflow:hidden;margin-top:0.5em");
            var szListImage = "";

			var szDesc = markers[i].properties.description;
			try	{
				szDesc = maptune.jsapi.onOpenInfoWindow(szDesc,markers[i],"sidebar");
			}
			catch (e){}

			if ( (!layer.duration || (markers.length < 500) || (szDate == _mapup_explDate)) && szDesc.match(/\<img/i) ){
				var match1 = null;
				var match2 = null;

				// try string delimiter "
				match1 = szDesc.match(/<img.+?src=[\"](.+?)[\"].*?>/i);
				// try string delimiter '
				match2 = szDesc.match(/<img.+?src=[\'](.+?)[\'].*?>/i);

				var szImg1 = (match1 && (match1.length>1))?(match1[1]):"";
				var szImg2 = (match2 && (match2.length>1))?(match2[1]):"";

				// only one string delimiter may be successfull 
				var szImg = szImg1 + szImg2;

				var szTitle = markers[i].properties.name;
				var layerP = _mapup_getLayerParam(layer.properties.name);
				if ( layerP && layerP.titlePath ){
					szTitle = _mapup_getTitleByPath(markers[i],layerP.titlePath);
				}
				try	{
					szTitle = maptune.jsapi.onInfoWindowTitle(szTitle,markers[i]);
				}
				catch (e){}

				szListImage += "<img class=\"gallery-image\" src=\""+szImg+"\" title=\""+szTitle+"\" onerror='this.src = \"resources/images/image-not-found.png\";' />";

				szListImage += "<p style='font-size:0.7em;line-height:1.2em;margin:0;margin-top:0.5em;'><a href=\"javascript:void()\">"+szTitle+"</a></p>";

			}else{
			//	szListImage = "<a href=\"javascript:void()\"><img src='"+myIcon+"' height='20' style='margin-right:3px' /></a>";
			}

			$(szListImage).appendTo(listItem); 
			if ( (typeof(handler) != "undefined") && handler ){
				listItem.onclick = handler;
			}
			listRow.appendChild(listItem);


			if ( this.map && markers[i].gOverlayObject ){
				markers[i].gOverlayObject.listItem = listItem;
				_map_createMyTooltipListener(listItem, markers[i].gOverlayObject);
			}
		}
	listDiv.appendChild(listRow);
	this.itemList.appendChild(listDiv);
	}

	// if more items than limit, make notice
	if ( nItems >= maxItems ){
		listItem = document.createElement("div");
		listItem.setAttribute("class","listitem");
		$("<a>&nbsp;&nbsp;(lista troncata, ci sono "+(markers.length-maxItems)+" elementi di pi...)</a>").appendTo(listItem); 
		this.itemList.appendChild(listItem);
	}
	else if ( nItems <= 0 ){
		listItem = document.createElement("div");
		listItem.setAttribute("class","listitem");
		//$("<a href=\'javascript:maptune.jsapi.setListContent(\""+layer.properties.name+"\",\"piu\");\' >&nbsp;&nbsp;- tutti "+(markers.length-nItems)+" elementi fuori quadro</a>").appendTo(listItem); 
		$("<a href=\'javascript:maptune.jsapi.zoomToLayer(\""+layer.properties.name+"\");\' >&nbsp;&nbsp;- tutti "+(markers.length-nItems)+" elementi fuori quadro</a>").appendTo(listItem); 
		this.itemList.appendChild(listItem);
	}
	else if ( nItems < markers.length ){
		listItem = document.createElement("div");
		listItem.setAttribute("class","listitem");
		//$("<a href=\'javascript:maptune.jsapi.setListContent(\""+layer.properties.name+"\",\"piu\");\' >&nbsp;&nbsp;- tutti "+(markers.length-nItems)+" elementi fuori quadro</a>").appendTo(listItem); 
		$("<a href=\'javascript:maptune.jsapi.zoomToLayer(\""+layer.properties.name+"\");\' ><br>&nbsp;&nbsp;"+(markers.length-nItems)+" elementi fuori quadro</a>").appendTo(listItem); 
		this.itemList.appendChild(listItem);
	}
};

MapUp.prototype.closeActualInfoWindow = function(marker) {
	$(".leaflet-popup-close-button").click();
};

/* ...................................................................* 
 *  l o c a l e   f u n c t i o n s                                   * 
 * ...................................................................*/ 

/* ...................................................................* 
 *  method wrapper for callbacks                                      * 
 * ...................................................................*/ 
 /**
 * synchronize on info window close
 */
function _mapup_onInfoWindowClose() {

	var fRedraw = actualInfoMarker?(!(actualInfoMarker.data.parent && (actualInfoMarker.data.parent.fShowInfoInList || actualInfoMarker.data.parent.properties.fGallery))):false;

	actualInfoMarker = null;
	requestInfoMarker = null;
	_mapUp.removeHighlightSidebarItem(_mapUp.map);

	if ( maptune.jsapi.fSidebarClickZoom && fRedraw){
		_mapUp.clearSidebar();
		_mapUp.drawSidebar();
	}
	maptune.jsapi.fSidebarClickZoom = false;
}
 /**
 * synchronize on info window open
 */
function _mapup_onInfoWindowOpen(marker) {
	_mapUp.highlightSidebarItem(_mapUp.map,marker);
}
/**
 * set highlight in itemlist
 */
function _mapup_highlightSidebarItem(map,marker) {
	_mapUp.highlightSidebarItem(map,marker);
}

/**
 * lookup szLayerName in maptune.jsapi.mapParam object, and return the parameter of the layer
 * @param szLayerName the name of the layer
 * @return an object with layer parameter or null
 */
function _mapup_getLayerParam(szLayerName){
	var layerP = null;
	if ( maptune.jsapi.mapParam && maptune.jsapi.mapParam.layers ){
		var layersP = maptune.jsapi.mapParam.layers;
		for ( var ii=0; ii<layersP.length; ii++ ){
			if ( layersP[ii].name == szLayerName ){
				layerP = layersP[ii];
			}
		}
	}
	return layerP;
}
/**
* get title text, defined by a data path 
 * @param marker the source (json)
 * @param szTitlePath the source path description to compose the title
 * @return an object with layer parameter or null
 */
function _mapup_getTitleByPath(marker,szTitlePath){
	szTitle = "";
	pathA = szTitlePath.split("+");
	for ( var t=0; t<pathA.length; t++ ){
		szTitle += eval("marker."+pathA[t] ) + " ";
	}
	return szTitle;
}

/* ...................................................................* 
 *  function with google maps api calls                               * 
 * ...................................................................*/ 
/**
 * parse the JSON data and create all layer overlays
 * loops through layer and sublayer and calls _mapup_makeLayer();
 * @param map the Google Maps API instance
 * @param layer JSON object of one layer
 * @param defaultIcon a default icon image for the marker
 */
function _mapup_getIcon(map,defaultIcon,layer,markers,i,szFlag) {	

		var layerP = _mapup_getLayerParam(layer.properties.name);
		//szFlag = 'small';
		// no Google Maps API loaded
		if ( typeof(GIcon) == 'undefined' ){
			return new Object({image:maptune.jsapi.getResourceUrl(markers[i].properties.icon)});
		}

		var icon = new GIcon(G_DEFAULT_ICON);
		icon.image = _mapup_szDefaultMarker;

		//	GR 03.09.2012 must be preset for tooltip.js
		icon.iconSize = new GSize(32, 37);

		if ( typeof(defaultIcon) != "undefined" ){
			icon.image = defaultIcon;
		}

		var nSize = 1;

		if ( layerP && layerP.markerSizeRule ){
			var mSR = layerP.markerSizeRule;
			try	{
				if ( mSR.regex ){
					var match = eval( "markers[i].properties."+mSR.source+".match("+mSR.regex+")" );
					if ( match ){
						nSize = parseFloat(match[mSR.matchIndex]) / (mSR.normalSizeValue||mSR.normalSize);
						nSize = Math.pow(nSize,mSR.pow||1);
						if (isNaN(nSize)){
							nSize = 1;
						}
					}
				}else{
					nSize = eval( "markers[i].properties."+mSR.source) / (mSR.normalSizeValue||mSR.normalSize||1);
					nSize = Math.pow(nSize,mSR.pow||1);
					if (isNaN(nSize)){
						nSize = 1;
					}
				}
			}
			catch (e){}
		}

		icon.iconAnchor = new GPoint(16, 32);

		if ( layerP && (layerP.markerType == "image") && markers[i].properties.data && markers[i].properties.data.IMMAGINE ){
			if ( !layerP.thumbnailRoot ){
				layerP.thumbnailRoot = "resources/images/tn/";
			}
			icon.image = maptune.jsapi.getResourceUrl(layerP.thumbnailRoot+markers[i].properties.data.IMMAGINE);
			icon.printImage = maptune.jsapi.getResourceUrl(layerP.thumbnailRoot+markers[i].properties.data.IMMAGINE);
			icon.shadow = maptune.jsapi.getResourceUrl("resources/icons/image_shadow.png");
			icon.iconSize = new GSize(52, 52);
			icon.shadowSize = new GSize(59, 55);
			icon.iconAnchor = new GPoint(0, 52);
			}
		else
		if ( layerP && (layerP.markerType == "numeric") ){
			var myIcon = maptune.jsapi.getResourceUrl("resources/icons/Google Maps Icons/iconr"+ (i+1) +".png");
			icon.iconSize = new GSize(16*nSize, 32*nSize);
			icon.infoWindowAnchor = new GPoint(8*nSize, 6*nSize);

			// layer has its own numeric icon root
			//
			if ( layerP.markerImageRoot ){
				myIcon = layerP.markerImageRoot + String(i+1) + "." + layerP.markerImageType;
				icon.iconSize = new GSize(32*nSize, 32*nSize);
				icon.iconAnchor = new GPoint(16*nSize, 32*nSize);
				icon.infoWindowAnchor = new GPoint(15*nSize, 6*nSize);
			}

			// layer has a category list to define category specific numeric icon roots
			//
			if ( layerP.categoryList ){
				for ( var a in layerP.categoryList ){
					if ( eval("markers[i].properties.category.match(/"+a+"/i)") ){
						if ( layerP.categoryList[a].markerImageRoot ){
							myIcon = layerP.categoryList[a].markerImageRoot + String(i+1) + "." + layerP.markerImageType;
							icon.iconSize = new GSize(32*nSize, 32*nSize);
							icon.iconAnchor = new GPoint(16*nSize, 32*nSize);
							icon.infoWindowAnchor = new GPoint(15*nSize, 6*nSize);
						}
					}
				}
			}

			icon.image = myIcon;
			icon.printImage = myIcon;
		}
		else
		if ( layerP && (layerP.markerType == "custom") ){
			if ( layerP.smallImage && ((szFlag && szFlag == 'small') || (layerP.iconType == 'small')) ){
				myIcon = layerP.smallImage;
				icon.iconSize = new GSize(15, 15);
				icon.iconAnchor = new GPoint(7, 7);
				icon.infoWindowAnchor = new GPoint(15,6);
			}else
			if ( layerP.markerImage ){
				myIcon = layerP.markerImage;
				var width  = layerP.markerSize?layerP.markerSize.width:32;
				var height = layerP.markerSize?layerP.markerSize.height:37;
				icon.iconSize = new GSize(width*nSize, height*nSize);
				icon.iconAnchor = new GPoint(width/2*nSize, height*nSize);
				icon.infoWindowAnchor = new GPoint(15*nSize,6*nSize);
			}
			icon.image = myIcon;
			icon.printImage = myIcon;
		}
		else
		if ( layerP && (layerP.markerType == "symbol") ){

			myIcon = layerP.smallImage || maptune.jsapi.getResourceUrl(markers[i].properties.icon);
			nSize  = (markers[i].properties.iconscale && (markers[i].properties.iconscale!=1)) ? markers[i].properties.iconscale:nSize; 

			icon.iconSize = new GSize(15*nSize,15*nSize);
			icon.iconAnchor = new GPoint(7*nSize,7*nSize);
			icon.infoWindowAnchor = new GPoint(7*nSize,7*nSize);
			icon.image = myIcon;
			icon.printImage = myIcon;
		}
		else
		if ( layerP && (layerP.markerType == "categorical") ){
			// layer has a category list to define category specific numeric icon roots
			//
			if ( layerP.smallImage && ((szFlag && (szFlag == 'small')) || (layerP.iconType == 'small') ) ){
  				myIcon = layerP.smallImage;
				icon.iconSize = new GSize(15, 15);
				icon.iconAnchor = new GPoint(7, 7);
				icon.infoWindowAnchor = new GPoint(15,6);
			}
			if ( layerP.categoryList ){
				for ( var a in layerP.categoryList ){
					var category = layerP.category || "category";
					try {
						var data = eval("markers[i].properties['"+category+"']") ||
								   eval("markers[i].properties.data['"+category+"']");
						if ( eval("data.match(/"+a+"/i)") ) {
							if ( ((szFlag && (szFlag == 'small')) || (layerP.iconType == 'small') ) ){
								if ( layerP.categoryList[a].smallImage ){
									myIcon = layerP.categoryList[a].smallImage;
									icon.iconSize = new GSize(15, 15);
									icon.iconAnchor = new GPoint(7, 7);
									icon.infoWindowAnchor = new GPoint(15,6);
									break;
								}else{
									myIcon = maptune.jsapi.getResourceUrl(_mapup_szDefaultSmallMarker);
									icon.iconSize = new GSize(15, 15);
									icon.iconAnchor = new GPoint(7, 7);
									icon.infoWindowAnchor = new GPoint(15,6);
									break;
								}
							}
							if ( layerP.categoryList[a].markerImage ){
								myIcon = layerP.categoryList[a].markerImage;
								icon.iconAnchor = new GPoint(16, 32);
								break;
							}
						}
					}
					catch (e){}
				}
			}
			if ( myIcon ){
				icon.image = myIcon;
				icon.printImage = myIcon;
			}
		}
		else
		if (  markers[i].properties.icon || markers[i].properties.smallicon ){

			// test small/large icon 
			// ---------------------
			var fSmallIcon = true;
			if ( _mapUp.timeline && layer.duration && (_mapup_explDate !== "") ){
				var d = new Date(Number(markers[i].properties.utime));
				var szDate = szDayA[(d.getDay())] + " " + d.getDate()+" " +szMonthA[(d.getMonth())]+ " " +d.getFullYear();
				if ( _mapup_explDate == szDate ){
					fSmallIcon = false;
				}
			}
			if ( 0 && layer.fShowInfoInList && markers[i].properties.icon){
				fSmallIcon = false;
			}
			if ( layerP && layerP.markerType == "small"){
				fSmallIcon = true;
			}
			if ( markers[i].properties.smallicon && fSmallIcon ){
				var nScale = markers[i].properties.iconscale? markers[i].properties.iconscale:1; 
				icon.image = maptune.jsapi.getResourceUrl(markers[i].properties.smallicon);
				icon.printImage = maptune.jsapi.getResourceUrl(markers[i].properties.smallicon);
				icon.iconSize = new GSize(15*nScale, 15*nScale);
				icon.iconAnchor = new GPoint(7*nScale, 7*nScale);
				icon.legendimage = maptune.jsapi.getResourceUrl(markers[i].properties.icon);

			}else{
				var nScale = markers[i].properties.iconscale? markers[i].properties.iconscale:1; 
				icon.image = maptune.jsapi.getResourceUrl(markers[i].properties.icon);
				icon.printImage = maptune.jsapi.getResourceUrl(markers[i].properties.icon);
				icon.iconSize = new GSize(32*nScale, 37*nScale);
				//icon.iconSize = new GSize(24, 24);
				var szShadowA = markers[i].properties.icon.split(".");
				icon.shadow = maptune.jsapi.getResourceUrl(String("./"+szShadowA[1]+"_shadow."+szShadowA[2]));
				icon.shadowSize = new GSize(37*nScale, 35*nScale);
				if (markers[i].iconalign){
					switch (markers[i].iconalign){
					case "left": 
					case "LEFT": 
						icon.iconAnchor = new GPoint(16*nScale, 32*nScale);
						break;
					case "center": 
					case "CENTER": 
						icon.iconAnchor = new GPoint(16*nScale, 16*nScale);
						break;
					case "right": 
					case "RIGHT": 
						icon.iconAnchor = new GPoint(32*nScale, 32*nScale);
						break;
					default:
						icon.iconAnchor = new GPoint(16*nScale, 32*nScale);
					}
				}else{
					icon.iconAnchor = new GPoint(16*nScale, 32*nScale);
				}
			}
		}
		else
		if ( szFlag && (szFlag == 'small') ){
			icon.image = maptune.jsapi.getResourceUrl(_mapup_szDefaultSmallMarker);
			icon.printImage = maptune.jsapi.getResourceUrl(_mapup_szDefaultSmallMarker);
			icon.iconSize = new GSize(15, 15);
			icon.iconAnchor = new GPoint(7, 7);
			icon.infoWindowAnchor = new GPoint(15,6);
		}
	// user defined icon			
	if (1){
		try	{
			var userIcon = maptune.jsapi.onGetIcon(icon,markers[i],i,szFlag);
			if ( userIcon )	{
				return userIcon;
			}
		}
		catch (e){}
		try	{
			if ( layerP && layerP.onGetIcon ){
				var userIcon = layerP.onGetIcon(icon,markers[i],i,szFlag);
				if ( userIcon )	{
					return userIcon;
				}
			}
		}
		catch (e){}
		}
	return icon;
}
/**
 * parse the JSON data and create all layer overlays
 * loops through layer and sublayer and calls _mapup_makeLayer();
 * @param map the Google Maps API instance
 * @param layer JSON object of one layer
 * @param defaultIcon a default icon image for the marker
 */
MapUp.prototype.makeLayer = function(map,layerObj,defaultIcon) {	
		
	if ( !map ){
		return;
	}
	if ( !layerObj.data ){
		return;
	}

	// GR 23.08.2016 notify user
	maptune.jsapi.onDrawLayer(layerObj.data);

	if ( !this.isLayerInMapScale(layerObj) ){
		this.clearOneLayer(layerObj);
		return;
	}

	__timer_reset();

	var layer = layerObj.data;
	var markers = layer.features;
	if ( !markers || markers.length <= 0 ){
		return;
	}
	
	// get timestamps and calcolate duration
	if (!layer.duration && markers[0].properties.utime){
		layer.lastTime  = layer.firstTime = 0;	
		for ( var i=0; i<markers.length; i++ ){
			if ( !isNaN(markers[i].properties.utime) ){
				if ( !layer.lastTime && !layer.firstTime ){
					layer.lastTime  = layer.firstTime = markers[i].properties.utime;	
				}
				layer.firstTime = Math.min(layer.firstTime,markers[i].properties.utime);
				layer.lastTime  = Math.max(layer.lastTime,markers[i].properties.utime);
			}
		}
		layer.duration = layer.lastTime-layer.firstTime;
		layer.duration = Math.max(layer.duration,1);
		if ( !this.timeline ){
			this.timeline = new Timeline(this);
			this.timeline.addLayer(layerObj);
			this.timeline.setTimeWindow("last",10,layer.lastTime);
			this.timeline.timescope = "today";
			if ( markers.length < 150 ){
				this.timeline.timescope = "all";
			}
			if ( _mapup_getLayerParam(layerObj.name) && _mapup_getLayerParam(layerObj.name).initialTimeScope){
				this.timeline.timescope = _mapup_getLayerParam(layerObj.name).initialTimeScope;
			}
			_mapUp.setTimeScope(this.timeline.timescope);
		}
	}
	
	// get number of visible marker
	var layerP = _mapup_getLayerParam(layerObj.name);
	var __nLargeIconMaxCount = layerP?(layerP.maxLargeIcons||50):50;
	var __nMinLargeIconZoom = layerP?(layerP.minLargeIconZoom||15):15;

	var __nCount = 0;
	var __nFilter = 0;
	var __nTime = 0;
	if ( 1 ){
		for( var i=0; i < markers.length; i++ ) {
			var fInMap	  = this.isMarkerInMapBounds(map,markers[i],0);
			var fInFilter = this.isMarkerInSearchQuery(layerObj,markers[i]) && this.isMarkerInFilter(layerObj,markers[i]);
			var fInTime   = this.isMarkerInTimeLap(markers[i]);

			if ( fInMap && fInFilter && fInTime ){
				__nCount++;
			}
			if ( !fInFilter ){
				__nFilter++;
			}
			if ( !fInTime ){
				__nTime++;
			}
		}
		var old = layerObj.fNoSmall;
		layerObj.fNoSmall = (_mapUp.actualMapZoom < __nMinLargeIconZoom)?false:true;
//		layerObj.fNoSmall = (__nCount < __nLargeIconMaxCount)?layerObj.fNoSmall:false;
		if ( old != layerObj.fNoSmall ){
			this.clearOneLayer(layerObj);	
		}

		layerObj.nMarkerCount		= __nCount;
		layerObj.nMarkerFiltered	= __nFilter;
		layerObj.nMarkerOutOfTime	= __nTime;
	}else{
		layerObj.nMarkerCount		= __nLargeIconMaxCount+1;
		layerObj.nMarkerFiltered	= 0;
		layerObj.nMarkerOutOfTime	= 0;
	}

	// make a pause every n marker to get the rendering
	this.maxFlushMarker = 1000; // this.markerClusterer?25:1000000;
	this.nMarker = 0;
	
	for( var i=0; i < markers.length; i++ ) {

		// if marker already rappresented on map and has info window, do nothing 
		if ( markers[i].gOverlayObject && markers[i].gOverlayObject == actualInfoMarker ){
			continue;
		}

		this.makeOverlay(map,layerObj,markers,i,defaultIcon,layerObj.fNoSmall?'normal':'small');

		if ( (__timer_getMS() > 250) || (this.nMarker > this.maxFlushMarker) ){
			maptune.xmapUp = this;
			setTimeout("maptune.xmapUp.drawLayer()",10);
			return;
		}
	}
	if (this.markerClusterer !== null) {
		this.markerClusterer.resetViewport();
		this.markerClusterer.redraw();
	}
	if (this.markerDeclutter !== null) {
		this.markerDeclutter.resetViewport();
		this.markerDeclutter.redraw();
		_map_redraw();
	}

	if ( this.timeline && layer.duration ){
		this.timeline.addLayer(layerObj);
		this.timeline.showTimeWindow();
	}

//	this.drawSidebar();

};


MapUp.prototype.makeOverlay = function(map,layer,markers,i,defaultIcon,szFlag) {	
			
	markers[i].fVisible = ( this.isMarkerInMapBounds(map,markers[i],0) &&
							this.isMarkerInSearchQuery(layer,markers[i])   &&
							this.isMarkerInFilter(layer,markers[i])	&&
							this.isMarkerInTimeLap(markers[i])		);

	if ( !markers[i].fVisible ){
		this.clearOneObject(markers[i]);
		return;
	}else if (  markers[i].gOverlayObject ){
		return;
	}

	// create the different map objects

	if ( markers[i].multigeometry ){
		for ( var g=0; g<markers[i].multigeometry.length; g++ ){
			this.makeOverlayObjects(map,layer,markers,i,g,defaultIcon,szFlag);
		}
	}else{
		this.makeOverlayObjects(map,layer,markers,i,0,defaultIcon,szFlag);
	}

};

MapUp.prototype.makeOverlayObjects = function(map,layer,markers,i,g,defaultIcon,szFlag) {	

	var __type = __getType(markers[i],g);
	var __szTooltip = __decode_utf8(markers[i].properties.name);

	var layerP = _mapup_getLayerParam(layer.data.properties.name);
	if ( layerP && layerP.titlePath ){
		__szTooltip = _mapup_getTitleByPath(markers[i],layerP.titlePath);
	}

	// try to get user defined tooltip
	try	{
		__szTooltip = maptune.jsapi.onMarkerTooltip(__szTooltip,markers[i]);
	}
	catch (e){}

	// 1. polygon area
	// ---------------
	if ( __type == "Polygon" ){
		var geometry = __getGeometry(markers[i],g);
		var polyPoints = Array();
		for(var ii=0; ii < geometry.coordinates[0].length; ii++) {
			polyPoints.push(new GLatLng(geometry.coordinates[0][ii][1], geometry.coordinates[0][ii][0]));
		}

		var style = markers[i].properties.style;
		style = (maptune.jsapi.onGetStyle ? maptune.jsapi.onGetStyle(markers[i].properties.style,markers[i],i) : style) || style;
		style = ((layerP && layerP.onGetStyle) ? layerP.onGetStyle(markers[i].properties.style,markers[i],i) : style) || style;

		var polygon = new GPolygon(	polyPoints,
									style.lineStyle.color,
									style.lineStyle.width*10,1,
									style.fillStyle.color,
									style.fillStyle.opacity || 0.3 );
		map.addOverlay(polygon);

		if ( g === 0 ){
			markers[i].gOverlayObject = polygon;
			markers[i].gOverlayObjectPartsA = new Array(0);
		}else{
			markers[i].gOverlayObjectPartsA.push(polygon);
		}

		// create missing properties and methods (resp.marker)
		polygon.myPosition = __doGetPolygonCenterGLatLng(polyPoints);
//				polygon.myPosition = new GLatLng(geometry.coordinates[0][1], geometry.coordinates[0][0]);
		polygon.getPoint = function(){return this.myPosition;};
		polygon.getIcon = function(){return new Object({iconAnchor:{x:0,y:0}});};

		// Attach click event to a polygon 
		// -------------------------------
		if ( (!layer.data.properties.events || layer.data.properties.events.match(/ONCLICK/)) ){
			var handler = _mapup_createMarkerClickHandler(map, polygon, layer, markers[i],"normal",i);
			_map_addEventListner(polygon,"click", handler);
			if ( requestInfoMarker && (requestInfoMarker == markers[i])) {
				handler();
			}
		}

		// create custom tooltip (ref.: tooltip.js)
		// -----------------------------------------
		if ( (!layer.data.properties.events || layer.data.properties.events.match(/ONOVER/)) ){
			if ( map && polygon && this.fMapTooltips){
				_map_createMyTooltip(polygon,__szTooltip,5,{callback:_mapup_highlightSidebarItem});
				_map_createMyTooltipListener(polygon, polygon);
			}
		}

		polygon.data = markers[i];
	}

	// 2. polyline 
	// ---------------
	else if ( __type == "LineString" ){
		var geometry = __getGeometry(markers[i],g);
		var polyPoints = Array();
		for(var ii=0; ii < geometry.coordinates.length; ii++) {
			polyPoints.push(new GLatLng(geometry.coordinates[ii][1], geometry.coordinates[ii][0]));
		}
		var style = markers[i].properties.style;
		style = maptune.jsapi.onGetStyle ? maptune.jsapi.onGetStyle(markers[i].properties.style,markers[i],i) : style;
		style = (layerP && layerP.onGetStyle) ? layerP.onGetStyle(markers[i].properties.style,markers[i],i) : style;
		
		var polyline = new GPolyline(polyPoints,
											style.lineStyle.color,
									 Number(style.lineStyle.width),
											style.lineStyle.opacity||1.0);

		polyline.myPosition = __doGetPolygonCenterGLatLng(polyPoints);
		polyline.getPoint = function(){return this.myPosition;};
		polyline.getIcon = function(){return new Object({iconAnchor:{x:0,y:0}});};

		// Attach click event to a polyline
		// --------------------------------
		var handler = _mapup_createMarkerClickHandler(map, polyline, layer, markers[i],"normal",i);
		_map_addEventListner(polyline,"click", handler);
		if ( requestInfoMarker && (requestInfoMarker == markers[i])) {
			handler();
		}

		map.addOverlay(polyline);

		if ( g === 0 ){
			markers[i].gOverlayObject = polyline;
			markers[i].gOverlayObjectPartsA = new Array(0);
		}else{
			markers[i].gOverlayObjectPartsA.push(polyline);
		}

		polyline.data = markers[i];

		// create custom tooltip (ref.: tooltip.js)
		// -----------------------------------------
		if ( map && polyline && this.fMapTooltips){
			_map_createMyTooltip(polyline,__szTooltip,5,{callback:_mapup_highlightSidebarItem});
			_map_createMyTooltipListener(polyline, polyline);
		}

	}
	// 3. push pin 
	// --------------
	else if ( __type == "Point" ){

		if ( ++this.nMarker > this.maxFlushMarker ){
			return;
		}
		
		// get icon object 
		var icon = _mapup_getIcon(map,defaultIcon,layer.data,markers,i,szFlag);
		// make marker 
		var marker = new GMarker(new GLatLng(markers[i].geometry.coordinates[1], markers[i].geometry.coordinates[0]), {icon: icon, title:__decode_utf8(markers[i].properties.name)});
		// save for further usage
		markers[i].gOverlayObject = marker;
		// and add to the map
		map.addOverlay(marker);

		marker.data = markers[i];
		
		// create custom tooltip (ref.: tooltip.js)
		// -----------------------------------------
		if ( this.fMapTooltips ){
			_map_createMyTooltip(marker,__szTooltip,5,{callback:_mapup_highlightSidebarItem,autopan:this.fSidebarTooltipsAutoPan});
			_map_createMyTooltipListener(marker, marker);
		}

		// Attach click event to show info window
		// --------------------------------------
		if ( markers[i].fVisible && !markers[i].fSuppressInfo ){
			var handler = _mapup_createMarkerClickHandler(map, marker, layer, markers[i],"normal",i);
			_map_addEventListner(marker, "click", handler);

			if ( requestInfoMarker && (requestInfoMarker == markers[i])) {
				handler();
			}
		}
		
		// GR 14.01.2012 add to clusterer, if present
		if (this.markerClusterer != null) {
          this.markerClusterer.addMarkers(new Array(marker),true);
        }
		if ((this.markerDeclutter != null) && !( (layerP !== null) && (layerP.markerCluster == 'false')) ) {
          this.markerDeclutter.addMarkers(new Array(marker),true);
        }

	}
};

function __getGeometry(feature,i){
	if (typeof(i) == "undefined"){
		i = 0;
	}
	if ( feature.multigeometry ){
		return feature.multigeometry[i];
	}
	else{
		return feature.geometry;
	}
}
function __getCoordinates(feature,i){

	var geometry = __getGeometry(feature,i);
	if ( geometry ){
		if ( geometry.type == "Point" ){
			return geometry.coordinates;
		} else if ( geometry.type == "LineString" ){
			return geometry.coordinates[0];
		} else{
			return geometry.coordinates[0][0];
		}
	}
	return null;
}
function __getType(feature,i){
	if (typeof(i) == "undefined"){
		i = 0;
	}
	if ( feature.geometry ){
		return feature.geometry.type;
	}
	else 
	if ( feature.multigeometry ){
		return feature.multigeometry[i].type;
	}
}
function __getBounds(feature,i){

	var sw = new Object({x:0,y:0});
	var ne = new Object({x:0,y:0});

	var nCount = 1;
	if ( feature.multigeometry ){
		nCount = feature.multigeometry.length;
	}

	for ( var g=0; g<nCount; g++ ){
        var coordinatesA = null;
		var geometry = __getGeometry(feature,g);
		if ( geometry && geometry.coordinates ){
			if ( geometry.type == "Point" ){
				sw.x = geometry.coordinates[0];
				sw.y = geometry.coordinates[1];
				ne.x = geometry.coordinates[0];
				ne.y = geometry.coordinates[1];
				return new Object({sw:sw,ne:ne});

			} else if ( geometry.type == "LineString" ){
				coordinatesA = geometry.coordinates;
			} else{
				coordinatesA = geometry.coordinates[0];
			}
			if ( coordinatesA && coordinatesA.length ){
				var starti = 0;
				if ( g === 0 ){
					sw.x = coordinatesA[0][0];
					sw.y = coordinatesA[0][1];
					ne.x = coordinatesA[0][0];
					ne.y = coordinatesA[0][1];
					starti = 1;
				}
				for ( i=starti; i<coordinatesA.length; i++ )	{
					sw.x = Math.min(sw.x,coordinatesA[i][0]);
					sw.y = Math.min(sw.y,coordinatesA[i][1]);
					ne.x = Math.max(ne.x,coordinatesA[i][0]);
					ne.y = Math.max(ne.y,coordinatesA[i][1]);
				}
			}
		}
	}
	return new Object({sw:sw,ne:ne});
}
function __doGetPolygonCenterGLatLng(ptList){
	var ptCenter = new Object({lat:0,lng:0});
	for ( var a in ptList ){
		ptCenter.lat += ptList[a].lat || 0;
		ptCenter.lng += ptList[a].lng || 0;
	}
	ptCenter.lat /= ptList.length;
	ptCenter.lng /= ptList.length;
	return(new GLatLng(ptCenter.lat,ptCenter.lng));
}
/**
 * parse the JSON data and create all layer overlays
 * loops through layer and sublayer and calls _mapup_makeLayer();
 * @param map the Google Maps API instance
 * @param layer JSON object of one layer
 * @param defaultIcon a default icon image for the marker
 */
MapUp.prototype.makeLegend = function(map,layer,defaultIcon,iconlist) {	
		
		var markers = layer.features;
		if ( !markers){
			return;
		}
		for(var i=0; i < markers.length; i++) {

			if ( markers[i].multigeometry ){
				this.createLegendItem(map,markers[i].multigeometry[0].type,markers[i],iconlist);
			}
			else
			if ( markers[i].geometry ){
				switch (markers[i].geometry.type){
					case "Polygon":
						this.createLegendItem(map,markers[i].geometry.type,layer,iconlist);
						break;
					case "LineString":
						this.createLegendItem(map,markers[i].geometry.type,layer,iconlist);
						break;
					default:
						var icon = _mapup_getIcon(map,defaultIcon,layer,markers,i);
						if ( icon && markers[i].properties.icon && (icon.image == maptune.jsapi.getResourceUrl(markers[i].properties.icon)) ){
							markers[i].properties.legenditem = this.translateLegendItem(markers[i].properties.legenditem);
							this.createLegendItem(map,markers[i].properties.icon,markers[i].properties.legenditem,iconlist);
						}
						break;
				}
			}
		}
};
/**
 * translate the legend item name, if dicionary defined
 * look in maptune.jsapi.mapParam for dictionary
 * @param szItemText the original legend item text
 */
MapUp.prototype.translateLegendItem = function(szItemText) {	
	if ( maptune.jsapi.mapParam.legend && maptune.jsapi.mapParam.legend.dictionary ) {
		var dict = maptune.jsapi.mapParam.legend.dictionary;
		for ( var a in dict ){
			if ( eval("szItemText.match(/"+a+"/)") ){
				return eval("dict['"+a+"']");
			}
		}
	}
	return szItemText;
};
/**
 * highlight the item in the sidebar, that corresponds to the given marker
 * if no marker given, rehighlight the last one
 * @param map the Google Maps API instance
 * @param marker the map marker object
 */
var oldHighLightMarker = null;
var oldHighLightItem = null;
var oldHighLightItemBg = null;
MapUp.prototype.highlightSidebarItem = function(map,marker) {

	// if we have an info window, this sets the highlight
	if ( actualInfoMarker && (marker != actualInfoMarker) ){
		return;
	}
	// if no marker given, look for the last one
	if ( marker == null ){
		marker = this.oldHighLightMarker;
	}
	if ( marker == null ){
		return;
	}
	// highlight the sidebar listitem of the marker
	// evtl. scroll sidebar to make visible
	//

	if ( marker.listItem ){

		// remove last highlight
		//
		this.removeHighlightSidebarItem(map);

		_map_setDestinationWaypoint(marker);

        this.oldHighLightItem = marker.listItem;

		if ( marker.listItem.childNodes.length == 1 ){
			marker.listItem.setAttribute("class","listitem listitemselected listitemexpanded");
		}else{
			marker.listItem.setAttribute("class","listitem listitemselected");
		}

		// calcolate item offset and if outside, scroll sidebar
		this.scrollToSidebarItem(map,marker.listItem);
	}
};
MapUp.prototype.removeHighlightSidebarItem = function(map) {

	if ( map == null ){
		return;
	}
	// remove last highlight
	//
    /**
	if ( this.oldHighLightItem ){
		this.oldHighLightItem.style.background = this.oldHighLightItemBg;
		this.oldHighLightItem = null;
		this.oldHighLightMarker = null;
	}
    **/
    if ( this.oldHighLightItem ){
        this.oldHighLightItem.setAttribute("class","listitem ui-btn");
    }

};
/**
 * scroll to the item in the sidebar
 * @param map the Google Maps API instance
 * @param marker the map marker object
 */
MapUp.prototype.scrollToSidebarItem = function(map,item) {
	if ( !this.fAutoScrollSidebar ){
		return;
	}
	// calcolate item offset and if outside, scroll sidebar
	var div = this.itemListDiv;
	var offset = 0;
	var height = item.offsetHeight;
	if ( item && (item != div) ){
		offset += item.offsetTop;
	}
	//div.scrollTop=offset-div.offsetTop-div.clientHeight/3;
	if ( (offset+height < div.scrollTop)		||
		 (offset > div.scrollTop+div.clientHeight)	){
		div.scrollTop=offset-div.offsetTop-div.clientHeight/3;
	}
};
/**
 * save the scroll of the sidebar
 */
MapUp.prototype.saveSidebarScroll = function() {
	var div = this.itemListDiv.parentNode;
	this.savedSidebarScroll = div.scrollTop;
};
/**
 * set the saved scroll of the sidebar
 */
MapUp.prototype.setSavedSidebarScroll = function() {
	if ( !this.fAutoScrollSidebar ){
		return;
	}
	if ( this.savedSidebarScroll ){
		var div = this.itemListDiv.parentNode;
		div.scrollTop = this.savedSidebarScroll;
	}
};

/* ...................................................................* 
 *  helper                                                            * 
 * ...................................................................*/ 

function _mapup_createMarkerClickHandlerGoto(map, marker, layer, info, szMode, i ) {
	return function() {

		try {
			//maptune.jsapi.forceMap();
		}
		catch (e){}

		if ( fCenterMapToInfoMarker )
			try {
				requestInfoMarker = marker;
				var coordinates = marker.getCoordinates();
				//map.panTo(new GLatLng(coordinates[1],coordinates[0]));
				maptune.jsapi.panTo(coordinates[1],coordinates[0]);
			}
			catch (e){}

		_mapup_createMarkerClickHandler(map, marker, layer, info, szMode + "|listitem", i )();
	};
}
/**
 * creates a handler to open an info window on the marker
 * @param map the Google Maps API instance
 * @param marker the Google Maps marker object
 * @param defaultIcon a default icon immage for the marker
 */
function _mapup_createMarkerClickHandler(map, marker, layer, info, szMode, i) {

	return function() {

		if ( szMode.match(/listitem/) ){
			maptune.jsapi.fSidebarClick = true;
		}

		if ( actualInfoMarker == marker ){
			maptune.jsapi.fSidebarClickZoom = true;
			_mapUp.clearSidebar();
			_mapUp.drawSidebar();
			//_map_setZoom(map,_map_getZoom(map)+1);
			return false;
		}

		// calcolate auto clip description by page width
		//
		var pageWidth  = parseFloat($(_mapUp.mapDiv).css("width"));
		var mWidth = Math.floor(Math.min(300,pageWidth/3*2));
		var pageHeight = parseFloat($(_mapUp.mapDiv).css("height"));
		var mHeight = Math.floor(Math.min(500,pageHeight/3));

		var fDescr = !maptune.jsapi.fSidebarClick || layer.data.properties.fGallery;
		fDescr = (pageWidth >= 500)?fDescr:false;

		var nClipDescription = (maptune.jsapi.mapParam && maptune.jsapi.mapParam.all && maptune.jsapi.mapParam.all.smallInfoClipDescription)?Number(maptune.jsapi.mapParam.all.smallInfoClipDescription):200;

		// get title ( + user defined )
		//
		var szTitle = info.properties.name;
		var layerP = _mapup_getLayerParam(layer.data.properties.name);
		if ( layerP && layerP.titlePath ){
			szTitle = _mapup_getTitleByPath(info,layerP.titlePath);
		}

		try	{
			szTitle = maptune.jsapi.onInfoWindowTitle(szTitle,info);
		}
		catch (e){}

		// make info content
		//
		var szInfo = "<div class=\"InfoWindow\" >";
		szInfo += "<div class=\"InfoWindowHeader\" style=\"max-width:"+(pageWidth*0.66)+"px\">"+szTitle+"<\/div>";

		var szDesc = "";
		maptune.jsapi.szInfoWindowFullDescription = szInfo + info.properties.description;
		
		if ( fDescr || !szTitle.length || (info.properties.description.length < nClipDescription) ){

			// insert full description as defined in source
			// --------------------------------------------
			szDesc += "<div class=\"InfoWindowBody\" " + "style=\"max-width:"+(pageWidth*0.66)+"px;max-height:"+(pageHeight*0.33)+"px;overflow:auto\"" + " >" + info.properties.description + "<\/div>";

		}else{

			// insert small description parsed from data, and link to maptune.jsapi.popupFullDescription()
			// ------------------------------------------------------------------------------------------
			szDesc += "<div class=\"InfoWindowBody\" onclick=\"event.stopPropagation();maptune.jsapi.popupFullDescription();\" >";

			if ( info.properties.utime || info.properties.utimeStart || info.properties.utimeEnd ){

				if ( info.properties.utimeStart && info.properties.utimeEnd && (info.properties.utimeStart != info.properties.utimeEnd) ){
					var ds = new Date(Number(info.properties.utimeStart));
					var de = new Date(Number(info.properties.utimeEnd));
					var szDates = szDayA[(ds.getDay())] + " " + ds.getDate()+" " +szMonthA[(ds.getMonth())]+ " " +ds.getFullYear();
					var szDatee = szDayA[(de.getDay())] + " " + de.getDate()+" " +szMonthA[(de.getMonth())]+ " " +de.getFullYear();
					if ( ds.toDateString() == de.toDateString() ){
						var szTime = ds.toLocaleTimeString().substr(0,5)+" - "+de.toLocaleTimeString().substr(0,5);
						szDesc += "<div class=\"InfoWindowHeaderSub\">"+szDates+"&nbsp;&nbsp;"+szTime+"</div>";
					}else{
						szDesc += "<div class=\"InfoWindowHeaderSub\">"+szDates+" - "+szDatee+"</div>";
					}
				}else{
					var d = new Date(Number(info.properties.utime));
					var szDate = szDayA[(d.getDay())] + " " + d.getDate()+" " +szMonthA[(d.getMonth())]+ " " +d.getFullYear();
					szDesc += "<div class=\"InfoWindowHeaderSub\">"+szDate+"</div>";
				}
			}

			if ( maptune.jsapi.mapParam && maptune.jsapi.mapParam.all && maptune.jsapi.mapParam.all.smallInfoKeepImage ){
				// look for image in description, if yes, show it
//				var match = info.properties.description.match(/src=(?:\"|\')?([^>]*[^/].(?:jpg|jpeg|bmp|gif|png))(?:\"|\')?/i);
				var	match = info.properties.description.match(/<img.+?src=[\"\'](.+?)[\"\'].*?>/i);
				var szImg = (match && (match.length>1))?(match[1]):"";
				if ( szImg && szImg.length ){
					szDesc += "<a href=\"javascript:void()\"><img src='"+szImg+"' title='"+szTitle+"' style='margin-top:1em;margin-bottom:0.5em;margin-right:3px;height:100px;' onerror='this.src = \"resources/images/image-not-found.png\";' /></a>";
				}
			}
			/**
			szDesc += "</div>";
			szDesc += "<div style=\"clear:both;opacity:0.3;text-align:center\" >";
			szDesc += "<a href=\"javascript:maptune.jsapi.popupFullDescription();\">view <img src='resources/ui/arrow_right.png' height='22' /></a></div>";
			szDesc += "</div>";
			**/
			maptune.jsapi.infoWindowMarker = marker;				
			maptune.jsapi.closeFullDescription();
		}

		if ( fEmbedAudioInInfo && info.properties.data && info.properties.data.LNK_2 ){
			szDesc += maptune.jsapi.getEmbedAudioHTML(maptune.jsapi.resolveRelativeUrl(info.properties.data.LNK_2,info.properties.szUrl),250);
		}
		// query user defined info window content	
		//


		if ( fDescr || (maptune.jsapi.mapParam && maptune.jsapi.mapParam.all && maptune.jsapi.mapParam.all.smallInfoKeepImage && maptune.jsapi.mapParam.all.smallInfoKeepImage != "false" )){
			try	{
				szDesc = maptune.jsapi.onOpenInfoWindow(szDesc,info,"map");
			}
			catch (e){}
			szDesc += "<span class=\"InfoWindowFooter\" style=\"vertical-align:-0.25em;\">";
			if (this.fCollectItems || maptune.jsapi.mapParam.all.fCollectItems ){
				if ( layer.name == "Collection" ){
					szDesc += "<a href=\"#\" onclick=\"event.stopPropagation();_mapup_remove_item('"+layer.source+"','"+layer.name+"',"+i+")\" >"+"remove "+"</a>";
					szDesc += "<a href=\"#\" onclick=\"event.stopPropagation();_mapup_remove_item('"+layer.source+"','"+layer.name+"',"+i+")\" >&#x2605;</a>";
				}else{
					szDesc += "<a href=\"#\" onclick=\"event.stopPropagation();_mapup_collect_item('"+layer.source+"','"+layer.name+"',"+i+")\" >"+"collect "+"</a>";
					szDesc += "<a href=\"#\" onclick=\"event.stopPropagation();_mapup_collect_item('"+layer.source+"','"+layer.name+"',"+i+")\" >&#x2605;</a>";
				}
			}
			szDesc += "</span>";
		}

		if ( !szTitle || szTitle.length || !szMode || (szMode != "small") ){
			szInfo += szDesc;
		}

		szInfo += "</div>";

		// make info window	
		//
		if ( typeof(InfoBubble) != "undefined" ){
			if ( typeof(this.infoBubble) == "undefined" ){
				this.infoBubble = new InfoBubble({
				  maxWidth: mWidth,
				  maxHeight: mHeight,
				  shadowStyle: 1,
				  disableAnimation: true
				});
			}
			this.infoBubble.open(map, marker);
			this.infoBubble.setContent(szInfo);
			this.infoBubble.setOnClose(_mapup_onInfoWindowClose);
		}else{
			if ( !marker.onmap ){
				console.log("not on  map !!!");
			}
			// GR 29.03.2015 make shure, info window not exeeds page height !! 
			szInfo = "<div style='max-height:"+(mHeight+100)+"px;overflow:auto;margin:0;padding:0'>"+szInfo+"</div>";
			marker.setInfoBubble(szInfo);
			marker.openBubble();
			_map_addEventListner(marker, "openInfoBubble", function(){_mapup_onInfoWindowOpen(marker)});
			_map_addEventListner(marker, "closeInfoBubble", _mapup_onInfoWindowClose);
		}
		maptune.clickableImages("InfoWindow");
		actualInfoMarker = marker;

		if ( !layer.data.fShowInfoInList && !layer.data.properties.fGallery){
			if ( _mapUp.fInfoImmediately || (maptune.jsapi.mapParam && maptune.jsapi.mapParam.all && maptune.jsapi.mapParam.all.showInfoImmediately)){
				_mapUp.clearSidebar();
				_mapUp.drawSidebar();
			}	
			_mapUp.highlightSidebarItem(this.map,actualInfoMarker);
		}else
		if ( !layer.data.properties.fGallery ){
			_mapUp.highlightSidebarItem(this.map,actualInfoMarker);
		}

		// GR 12.10.2012 see tiptool.js
		//map.tiptool_.hide();

		return false;
	};
}
/**
 * creates a handler to go to a markers position on the map
 * @param map the Google Maps API instance
 * @param marker the Google Maps marker object
 * @param defaultIcon a default icon immage for the marker
 */
function _mapup_createGoToHandler(map, marker) {

	return function() {

		try{
			//maptune.jsapi.forceMap();
		}
		catch (e){}

		try{
			requestInfoMarker = marker;
			var coordinates = __getCoordinates(marker,0);
			maptune.jsapi.panTo(coordinates[1],coordinates[0]);
		}
		catch (e){}
	};
}
/**
 * checks if a marker is within visible map bounds
 * @param map the Google Maps API instance
 * @param marker the Google Maps marker object
 * @param defaultIcon a default icon immage for the marker
 */
MapUp.prototype.isPointInsidePolygon = function(point, polygon) {
    // ray-casting algorithm based on
    // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
    var x = point[0], y = point[1];
    var inside = false;
    for (var i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        var xi = polygon[i][0], yi = polygon[i][1];
        var xj = polygon[j][0], yj = polygon[j][1];

        var intersect = ((yi > y) != (yj > y))
            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
    }

    return inside;
};

/**
 * checks if a marker is within visible map bounds
 * @param map the Google Maps API instance
 * @param marker the Google Maps marker object
 * @param defaultIcon a default icon immage for the marker
 */
MapUp.prototype.isMapBoundsInPolygon = function(marker, g) {

	if ( !this.actualMapBounds ){
		return false;
	}

	var coordinates = __getCoordinates(marker,g);

	if ( !coordinates ){
		return false; 
	}
	if ( !this.isPointInsidePolygon([this.actualMapBounds[0].lat,this.actualMapBounds[0].lng],coordinates) ){
		return false;
	}
	if ( !this.isPointInsidePolygon([this.actualMapBounds[1].lat,this.actualMapBounds[1].lng],coordinates) ){
		return false;
	}

	return true;
};

/**
 * checks if a marker is within visible map bounds
 * @param map the Google Maps API instance
 * @param marker the Google Maps marker object
 * @param defaultIcon a default icon immage for the marker
 */
MapUp.prototype.isMarkerInMapBounds = function(map, marker, g) {

	if ( !this.actualMapBounds ){
		return false;
	}

	var markerBounds = __getBounds(marker,g);

	if ( markerBounds.sw.y > this.actualMapBounds[1].lat ||
		 markerBounds.ne.y < this.actualMapBounds[0].lat ||
		 markerBounds.sw.x > this.actualMapBounds[1].lng ||
		 markerBounds.ne.x < this.actualMapBounds[0].lng ){

		return false;
	}
	return true;
};

/**
 * checks if a given bBox is within visible map bounds
 * @param map the Google Maps API instance
 * @param bBox the coordinate box
 */
MapUp.prototype.isBoxInMapBounds = function(map, bBox) {

	if ( !this.actualMapBounds || !bBox ){
		return false;
	}
	// 1. check, if map zoom is belob bBox extent, if yes, return false
	if ( (this.actualMapBounds[1].lng - this.actualMapBounds[0].lng) > (bBox[2] - bBox[0]) ){
		return false;
	}
	// 2. check, if bBox is partialy visible 
	if ( bBox[1] > this.actualMapBounds[1].lat ||
		 bBox[3] < this.actualMapBounds[0].lat ||
		 bBox[0] > this.actualMapBounds[1].lng ||
		 bBox[2] < this.actualMapBounds[0].lng ){
		return false;
	}
	return true;
};


/**
 * checks if a marker is within search
 * @param marker the Google Maps marker object
 * @param defaultIcon a default icon immage for the marker
 */
MapUp.prototype.isMarkerInSearchQuery = function(layer,marker) {
	if ( this.szExcludeString && this.szExcludeString.length && marker.properties.name ){
		if ( eval('marker.properties.name.match(/'+this.szExcludeString+'/i)') ){
			return false;
		}
		if ( marker.properties.legenditem && eval('marker.properties.legenditem.match(/'+this.szExcludeString+'/i)') ){
			return false;
		}
	}
	if ( this.szSearchString && this.szSearchString.length && marker.properties.name ){

		if ( this.szSearchString.match(":") ){
			this.szSearchColumn = this.szSearchString.split(":")[0];
			this.szSearchString = this.szSearchString.split(":")[1];
		}
		if ( (typeof(this.szSearchColumn) != "undefined") && this.szSearchColumn.length && marker.properties.data && marker.properties[this.szSearchColumn] ){
			if ( eval('marker.properties.'+this.szSearchColumn+'.match(/'+this.szSearchString+'/i)') ){
				return true;
			}else{
				return false;
			}
		}
		if ( eval('marker.properties.name.match(/'+this.szSearchString+'/i)') ){
			return true;
		}else
		if ( marker.properties.legenditem && eval('marker.properties.legenditem.match(/'+this.szSearchString+'/i)') ){
			return true;
		}else
		if ( marker.properties.data && marker.properties.data.INDIRIZZO && eval('marker.properties.data.INDIRIZZO.match(/'+this.szSearchString+'/i)') ){
			return true;
		}else
		if ( marker.properties.description && marker.properties.description && eval('marker.properties.description.match(/'+this.szSearchString+'/i)') ){
			return true;
		}else{
			return false;
		}
	}
	else
	if ( this.szSearchStringA && this.szSearchStringA[String((layer.data.properties.name))] && marker.properties.name ){
		var szSearchString = this.szSearchStringA[String((layer.data.properties.name))];
		if ( eval('marker.properties.name.match(/'+szSearchString+'/i)') ){
			return true;
		}else
		if ( marker.properties.legenditem && eval('marker.properties.legenditem.match(/'+szSearchString+'/i)') ){
			return true;
		}else
		if ( marker.properties.data && marker.properties.data.INDIRIZZO && eval('marker.properties.data.INDIRIZZO.match(/'+szSearchString+'/i)') ){
			return true;
		}else
		if ( marker.properties.description && marker.properties.description && eval('marker.properties.description.match(/'+szSearchString+'/i)') ){
			return true;
		}else{
			return false;
		}
	}
	else
	if ( layer.data.szFilter ){
		var szSearchString = layer.data.szFilter;
		if ( eval('marker.properties.name.match(/'+szSearchString+'/i)') ){
			return true;
		}else
		if ( marker.properties.legenditem && eval('marker.properties.legenditem.match(/'+szSearchString+'/i)') ){
			return true;
		}else
		if ( marker.properties.data && marker.properties.data.INDIRIZZO && eval('marker.properties.data.INDIRIZZO.match(/'+szSearchString+'/i)') ){
			return true;
		}else
		if ( marker.properties.description && marker.properties.description && eval('marker.properties.description.match(/'+szSearchString+'/i)') ){
			return true;
		}else{
			return false;
		}
	}
	else{
		return true;
	}
};

/**
 * checks if a marker is within filter
 * @param marker the Google Maps marker object
 * @param layer the layer of the marker; filters can be layer specific
 */
MapUp.prototype.isMarkerInFilter = function(layer,marker) {
	if ( maptune.jsapi.filterA ){
		for ( f in maptune.jsapi.filterA ){
			if ( (f == layer.data.properties.name) && 
				 !( eval('marker.properties.name.match(/'+maptune.jsapi.filterA[f]+'/i)')) ){
				return false;
			}
		}
	}
	return true;
};
MapUp.prototype.isFilter = function() {
	if ( (typeof(maptune.jsapi.filterA) != "undefined") && maptune.jsapi.filterA.length ){
		return true;
	}
	return false;
};
MapUp.prototype.isQuery = function() {
	if ( this.szSearchString && this.szSearchString.length ){
		return true;
	}
	return false;
};

/**
 * checks if a marker is with timecode and within the defined timelap
 * @param marker the Google Maps marker object
 */
MapUp.prototype.isMarkerInTimeLap = function(marker) {
	if ( marker.properties.utime && this.timeline && this.timeline.active ){
		// marker time or starttime within timelap
		if ( (marker.properties.utime >= this.timeline.low ) &&
		     (marker.properties.utime <= this.timeline.high)   )  {
			return true;
		}
		if ( marker.properties.utimeEnd ){
			// marker endtime within timelap
			if ( (marker.properties.utimeEnd >= this.timeline.low ) &&
				 (marker.properties.utimeEnd <= this.timeline.high)   )  {
				return true;
			}
			// marker starttime before and endtime after the timelap
			if ( (marker.properties.utime < this.timeline.low ) &&
				 (marker.properties.utimeEnd > this.timeline.high)   )  {
				return true;
			}
		}
		return false;
	}
	return true;
};
/**
 * checks if a marker has timecode and is within past,present,future
 * @param marker the Google Maps marker object
 */
MapUp.prototype.getMarkerInTimeLapQualify = function(marker) {

	var d = new Date();
	d = new Date(d.getFullYear(),d.getMonth(),d.getDate());
	todayLow  = d.getTime();
	todayHigh = todayLow + 1000*60*60*24 - 1;

	if ( marker.properties.utime && this.timeline ){

		if ( marker.properties.utimeEnd ){
			if ( marker.properties.utimeEnd < todayLow ) {
				return "past";
			}
		}else{
			if ( marker.properties.utime < todayLow) {
				return "past";
			}
		}
		if ( marker.properties.utime > todayHigh ) {
			return "future";
		}
		return "present";
	}
	return "";
};

var Timeline = function(parent){
	this.firstTime = Number.MAX_VALUE;
	this.lastTime  = 0;
	this.layerA = new Array(0);
	this.active = true;
	this.framerate = 4;
	this.tail = 1;
	this.mapup = parent;
};
Timeline.prototype.addLayer = function(layer){
	this.layerA.push(layer);
	this.firstTime = Math.min(this.firstTime,layer.data.firstTime);
	this.lastTime  = Math.max(this.lastTime,layer.data.lastTime);
};
Timeline.prototype.removeLayer = function(layer){
	// remove the layer
	for ( var i=0; i<this.layerA.length; i++ ){
		if ( this.layerA[i] == layer ){
			this.layerA.splice(i,1);
		}
	}
	// recalc time window
	this.firstTime = Number.MAX_VALUE;
	this.lastTime  = 0;
	for ( var i=0; i<this.layerA.length; i++ ){
		this.firstTime = Math.min(this.firstTime,layer.data.firstTime);
		this.lastTime  = Math.max(this.lastTime,layer.data.lastTime);
	}
};
Timeline.prototype.showTimeWindow = function(){
	maptune.timeline = this;
	var szColor = "#444";
	/**
	if ( this.low > this.lastTime || this.high < this.firstTime || !this.active ){
		szColor = "#ddd";
	}
	**/
	var d1 = new Date(this.low);
	var d2 = new Date(this.high);
	var szDate  = "<div style='min-width:100px;color:"+szColor+"'>";
		szDate += "<div style='float:left;text-align:center'>";

		if ( this.szUnit == "month" ){
			szDate += "<div style='text-align:center'>";
			szDate += "<span>"+(szMonthLongA?szMonthLongA[d1.getMonth()]:d1.getMonth()+1)+"</span>";
			szDate += " <span>"+d1.getFullYear()+"</span>";
			szDate += "</div>";
		}else
		if ( this.szUnit == "today" ){
			szDate += "<span>"+(szDayLongA?szDayLongA[d1.getDay()]:"")+"</span>";
			szDate += "<span> &nbsp;"+d1.getDate()+"."+(d1.getMonth()+1)+"."+d1.getFullYear()+"</span>";
		}else
		if ( d1.getFullYear() != d2.getFullYear() ){
			szDate += "<span>"+d1.getDate()+"."+(d1.getMonth()+1)+"."+d1.getFullYear()+"</span>";
			szDate += "<span> - </span>";
			szDate += "<span>"+d2.getDate()+"."+(d2.getMonth()+1)+"."+d2.getFullYear()+"</span>";
		}else{
			szDate += "<span>"+d1.getDate()+"."+(d1.getMonth()+1)+"</span>";
			szDate += "<span> - </span>";
			szDate += "<span>"+d2.getDate()+"."+(d2.getMonth()+1)+" "+d2.getFullYear()+"</span>";
		}
		szDate += "</div>";
		//szDate += "<div style='float:right;margin-right:20px;font-weight:bold;'>";
		//szDate += "<a href='javascript:maptune.timeline.moveTimeWindow(-1)'> &lt; </a><a href='javascript:maptune.timeline.moveTimeWindow(1)'> &gt; </a>";
		//szDate += "&nbsp;";
		//// szDate += "<a href='javascript:maptune.timeline.toggleTimeWindow()'> ? </a>";
		//szDate += "</div>";
		szDate += "</div>";

	if ( $("#showtimelinedate")[0] ){
		/**
		if ( this.szUnit == "all" ){
			$("#timelapbuttons-date").css("visibility","hidden");
		}else{
			$("#timelapbuttons-date").css("visibility","visible");
		}
		**/
		$("#timelapbuttons-date").css("visibility","visible");

		$("#showtimelinedate")[0].innerHTML = szDate;
		$("#timelapbuttons").css("visibility","visible");
	}else{
		var szTmp = "";
		szTmp += '<div style="position:absolute;top:10px;left:10px;z-index:600">';
		szTmp += '<div id="timelapbuttons-date" class="btn-group btn-group-lg" style=";padding-right:5em;pointer-events:all;">';
		szTmp += '<label class="btn btn-default btn-lg" id="showtimelinedate" ></label><br>';
		szTmp += '<label class="btn btn-default btn-lg" id="datetimepicker1" onclick="event.preventDefault();$(\'#timelapbuttons-period\').toggle();">';
		szTmp += '<input type="text" class="form-control" style="display:none" />';
		szTmp += '<span><img src="./resources/ui/calendar.png" height="14px"></img>';
		szTmp += '</span>';
		szTmp += '</label>';
		szTmp += '<label class="btn btn-default btn-lg" title="time -" onclick="event.preventDefault();maptune.timeline.moveTimeWindow(-1);" >-</label>';
		szTmp += '<label class="btn btn-default btn-lg" title="time +" onclick="event.preventDefault();maptune.timeline.moveTimeWindow(1);" >+</label>';
		szTmp += '</div>';
		szTmp += '<br>';
		szTmp += '<div id="timelapbuttons-period" class="btn-group " style="pointer-events:all;">';
		szTmp += '<label class="btn btn-default btn-lg" onclick="event.preventDefault();maptune.jsapi.setTimeScope(\'today\');$(\'#timelapbuttons-period\').hide()">oggi</label>';
		szTmp += '<label class="btn btn-default btn-lg" onclick="event.preventDefault();maptune.jsapi.setTimeScope(\'today+7\');$(\'#timelapbuttons-period\').hide()">+7</label>';
		szTmp += '<label class="btn btn-default btn-lg" onclick="event.preventDefault();maptune.jsapi.setTimeScope(\'week\');$(\'#timelapbuttons-period\').hide()">settimana</label>';
		szTmp += '<label class="btn btn-default btn-lg" onclick="event.preventDefault();maptune.jsapi.setTimeScope(\'month\');$(\'#timelapbuttons-period\').hide()">mese</label>';
		szTmp += '<label class="btn btn-default btn-lg" onclick="event.preventDefault();maptune.jsapi.setTimeScope(\'all\');$(\'#timelapbuttons-period\').hide()">tutto</label>';
		szTmp += '</div>';
		szTmp += '</div>';
		
		$(szTmp).appendTo(this.mapup.mapDiv.parentNode); 
		$("#timelapbuttons-period").hide();		
		$("#showtimelinedate")[0].innerHTML = szDate;
	}

};
Timeline.prototype.hideTimeWindow = function(){
	if ( $("#showtimelinedate")[0] ){
		$("#showtimelinedate")[0].innerHTML = "";
		$("#timelapbuttons").css("visibility","hidden");
		$("#timelapbuttons-date").css("visibility","hidden");
	}
};
Timeline.prototype.setTimeWindow = function(szFlag,nDays,startTime){
	this.szUnit = szFlag;
	this.active = true;
	switch(szFlag){
		case "month":
				var d = new Date(startTime);
				this.high = d.getTime();
				d = new Date(d.getFullYear(),d.getMonth()-1,1);
				this.low = d.getTime();
				var nDaysInMonth = (32 - new Date(d.getFullYear(), d.getMonth(), 32).getDate());
				d = new Date(d.getFullYear(), d.getMonth(),nDaysInMonth);
				this.high = d.getTime() + 1000*60*60*24 - 1;
				break;

		case "today":
		case "week":
		case "last":
			if ( nDays && (nDays > 0) ){
				var d = new Date(startTime);
				d = new Date(d.getFullYear(),d.getMonth(),d.getDate());
				this.low  = d.getTime() - (1000*60*60*24 * (nDays-1));
				this.high = d.getTime() + 1000*60*60*24 - 1;
			}
			break;
		case "all":
			this.low = this.firstTime;
			this.high = this.lastTime;
			this.active = false;
			break;
	}

	$("#"+szFlag).prop('checked',true);
	if ( $("#timelapbuttons").buttonset){
		$("#timelapbuttons").buttonset('refresh');
	}

	this.showTimeWindow();
	if( this.layerA && this.layerA.length ){
		_mapUp.clearOneLayer(this.layerA[0]);
//		_mapUp.makeLayer(_mapUp.map,this.layerA[0],this.layerA[0].defaultIcon);
		_mapUp.redraw();
	}

	// inform user
	try{
		maptune.jsapi.onChangeTimeWindow(szFlag,nDays);
	}
	catch (e){}
};
Timeline.prototype.moveTimeWindow = function(nDelta,szUnit){
	if ( !szUnit ){
		szUnit = this.szUnit;
	}
	if ( szUnit){
		switch(szUnit){
			case "day":
			default:
				nDelta *= 1000*60*60*24;
				break;
			case "week":
				nDelta *= 1000*60*60*24*7;
				break;
			case "month":
				var d = new Date(this.low);
				var month = d.getMonth();
				var year  = d.getFullYear();
				month += nDelta;
				if ( month < 0 ){
					year--;
					month = 11;
				}
				if ( month > 11 ){
					year++;
					month = 0;
				}
				var d1 = new Date(year,month,1);
				var nDaysInMonth = (32 - new Date(year, month, 32).getDate());
				var d2 = new Date(year,month,nDaysInMonth);

				this.low = d1.getTime();
				this.high = d2.getTime() + 1000*60*60*24 - 1;
				nDelta = 0;
				break;
		}
	}else{
		nDelta = nDelta * (this.high - this.low);
	}
	this.high += nDelta;
	this.low  += nDelta;

	// _mapUp.clearOneLayer(this.layerA[0]);
	// _mapUp.makeLayer(_mapUp.map,this.layerA[0],this.layerA[0].defaultIcon);
	this.showTimeWindow();
	_mapUp.redraw();
};
Timeline.prototype.toggleTimeWindow = function(){
	this.active = !this.active;
	_mapUp.clearOneLayer(this.layerA[0]);
	_mapUp.makeLayer(_mapUp.map,this.layerA[0],this.layerA[0].defaultIcon);
};

Timeline.prototype.play = function(opt){

	this.saveLow = this.low;
	this.saveHigh = this.high;
	this.saveUnit = this.szUnit;

	if ( opt.tail ){
		this.firstTime -= (opt.tail+2) * 1000 * 60 * 60;
	}
	this.duration = this.lastTime - this.firstTime;
	this.start = this.firstTime;
	this.days = this.duration/1000/60/60/24;
	this.hours = this.duration/1000/60/60;
	this.minutes = this.duration/1000/60;
	if ( this.days > 20 ){
		this.lap = this.duration/this.days;
	}else
	if ( this.hours > 20 ){
		this.lap = this.duration/this.hours;
	}else{
		this.lap = this.duration/this.minutes;
	}
	this.play = true;
	if ( opt ){
		this.framerate = opt.framerate || this.framerate;
		this.tail = opt.tail || (opt.framerate ? 1:5);
		if ( opt.unit && (opt.unit == "hours") ){
			this.lap = this.duration/this.hours;
		}
	}
	this.next();
};

var szMonthLongA = ["Gennaio","Febbraio","Marzo","Aprile","Maggio","Giunio","Luglio","Agosto","Settembre","Ottobre","Novembre","Dicembre"];
var szMonthA = ["GEN","FEB","MAR","APR","MAG","GIU","LUG","AGO","SET","OTT","NOV","DIC"];
var szDayLongA = ["domenica","luned&#236;","marted&#236;","mercoled&#236;","gioved&#236;","venerd&#236;","sabato"];
var szDayA = ["dom","lun","mar","mer","gio","ven","sab"];
Timeline.prototype.next = function() {
	if ( this.start < this.lastTime ){
		this.low  = this.start;
		this.high = this.low + this.lap * this.tail;
		this.start += this.lap;
	}else{
		this.play = false;
	}
	var d = new Date(this.low);
	if ( $("#showtimelinedate")[0] ){
		$("#showtimelinedate")[0].innerHTML = "<span>"+d.getDate()+"-"+(d.getMonth()+1)+"-"+d.getFullYear()+"</span>";

		$(".post_content").show(); 
		$("#showdate")[0].innerHTML = 	"<span class=\"dateinfo\">"+szDayA[(d.getDay())]+"</span>"	+
										"<span class=\"day\">"+(d.getDate()<10?("0"+d.getDate()):(d.getDate()))+"</span><br />"	+
										"<span class=\"month\">"+szMonthA[(d.getMonth())]+"</span><br />"+
										"<span class=\"year\">"+d.getFullYear()+"</span>";
	}
	_mapUp.makeLayer(_mapUp.map,this.layerA[0],this.layerA[0].defaultIcon);
	if ( this.play ){
		maptune.timeline = _mapUp.timeline;
		setTimeout("maptune.timeline.next();",1000/this.framerate);
	}else{
		_mapUp.timeline = _mapUp.savedTimeline;
		_mapUp.timeline.showTimeWindow();
		_mapUp.makeLayer(_mapUp.map,this.layerA[0],this.layerA[0].defaultIcon);
		$(".post_content").hide(); 
	}
};
MapUp.prototype.setTimeScope = function(szScope){
	if ( this.timeline ){

		var days = 0;
		switch (szScope){
			case "today":
			case "today+7":
				days = (szScope=="today+7")?7:1;
				break;		
			case "day":
				days = 1;
				break;		
			case "week":
				days = 7;
				break;		
			case "month":
				days = 31;
				break;		
		}

		var d = new Date();
		var month = d.getMonth();
		var year  = d.getFullYear();
		var day   = d.getDate();
		var d1 = new Date(year,month,day);
		this.timeline.low  = d1.getTime();
		this.timeline.high = d1.getTime() + 1000*60*60*24*(days-1);

		this.timeline.setTimeWindow(szScope,days,this.timeline.high);
	}
};
MapUp.prototype.playTimelineOfLayer = function(szFlag,szName,opt){
	for ( var i=0; i<this.layer.length; i++ ){
		if ( (szName == null) || (this.layer[i].name == szName) ){
			this.savedTimeline = this.timeline;
			this.timeline = new Timeline(this);
			this.timeline.addLayer(this.layer[i]);
			this.timeline.play(opt);
			return;
		}
	}
};

/**
 * creates an entry of the marker icon legend
 * creates the entry, if the icon is not yet present
 * @param map the Google Maps API instance
 * @param icon the icon image
 * @param item the marker type (description) to show
 */
MapUp.prototype.createLegendItem = function(map,icon,item,iconlist) {
	if ( !this.legendDiv ){
		return;
	}

	if ( this.legendDiv.offsetWidth < 500 ){
		return this.createLegendItem_tableStyle(map,icon,item,iconlist);
	}

	if ( icon == "LineString" ){
		if ( !iconlist[icon+item.properties.name] ){
			var legendDiv = this.legendDiv;
			legendDiv.innerHTML += "<font weight=\"bold\" color=\""+item.features[0].properties.style.lineStyle.color+"\">&#x25AC;</font> " + item.properties.name + "&nbsp;&nbsp;";
			iconlist[icon+item.properties.name] = item.features[0].properties.style.lineStyle.color; 
		}
	}
	else
	if ( !iconlist[icon] ){
		var legendDiv = this.legendDiv;
		legendDiv.innerHTML += "&nbsp;<img src=\""+icon+"\" height=\"16\" />&nbsp;"+item;
		iconlist[icon] = icon; 
	}	
};
/**
 * creates an entry of the marker icon legend
 * creates the entry, if the icon is not yet present
 * @param map the Google Maps API instance
 * @param icon the icon image
 * @param item the marker type (description) to show
 */
var _mapup_legendTableNode = null;
var _mapup_legendTableRowNode = null;
var _mapup_legendTableCell = null;
var _mapup_nLegendTableCellLines = 0;
MapUp.prototype.createLegendItem_tableStyle = function(map,icon,item,iconlist) {

	if ( !this.legendDiv ){
		return;
	}
	if ( icon == "Polygon" ){
		if ( iconlist[icon+item.properties.name] ){
			return;
		}else if (item.properties.style) {
			iconlist[icon+item.properties.name] = item.properties.style.fillStyle.color; 
		}
	} else
	if ( icon == "LineString" ){
		if ( iconlist[icon+item.properties.name] ){
			return;
		}else if (item.properties.style) {
			iconlist[icon+item.properties.name] = item.properties.style.lineStyle.color; 
		}
	} else 
	if ( iconlist[icon] ){
		return;
	}else{
		iconlist[icon] = icon; 
	}
	
	var legendNode = this.legendDiv;
	var parentHeight = legendNode.parentNode.offsetHeight;
	
	if ( !legendNode.hasChildNodes() )	{
		_mapup_legendTableNode = document.createElement("table");
		_mapup_legendTableNode.setAttribute("cellspacing","0");
		_mapup_legendTableNode.setAttribute("cellpadding","0");
		legendNode.appendChild(_mapup_legendTableNode);
		_mapup_legendTableRowNode = document.createElement("tr");
		_mapup_legendTableRowNode.setAttribute("valign","top");
		_mapup_legendTableNode.appendChild(_mapup_legendTableRowNode);
		_mapup_nLegendTableCellLines = 0;
		_mapup_legendTableCell = document.createElement("td");
		_mapup_legendTableRowNode.appendChild(_mapup_legendTableCell);
	}else
	if ( _mapup_nLegendTableCellLines*24 >= (parentHeight - 3*24) ){
		_mapup_legendTableCell = document.createElement("td");
		_mapup_legendTableRowNode.appendChild(_mapup_legendTableCell);
		_mapup_nLegendTableCellLines = 0;
	}else{
		_mapup_legendTableCell.innerHTML += "<br>";
		_mapup_nLegendTableCellLines++;
	}
	if ( icon == "Polygon" && item.properties.style ){
		// _mapup_legendTableCell.setAttribute("valign","center");
		_mapup_legendTableCell.innerHTML += "<font weight=\"bold\" size=\"5px\" style=\"line-height:23px;vertical-align:-1px\" color=\""+item.properties.style.fillStyle.color+"\">&nbsp;&#x25A0; </font><span style=\"vertical-align:center;\" >&nbsp;&nbsp;" + item.properties.name + "&nbsp;&nbsp;</span>";
	}
	else
	if ( icon == "LineString" && item.properties.style ){
		// _mapup_legendTableCell.setAttribute("valign","bottom");
		_mapup_legendTableCell.innerHTML += "<font weight=\"bold\" size=\"2px\" style=\"line-height:23px\" color=\""+item.properties.style.lineStyle.color+"\">&nbsp;&#x25AC; </font><span style=\"vertical-align:center;\" >&nbsp;&nbsp;" + item.properties.name + "&nbsp;&nbsp;</span>";
	}
	else {
		_mapup_legendTableCell.innerHTML += "<img src=\""+icon+"\" height=\"22\" style=\"vertical-align:-15px;\" />&nbsp;"+"<span style=\"vertical-align:-50%;\" > " + item + "&nbsp;&nbsp;</span>";
	}	
};

/**
 * Q&D bind maptune methods to MapUp instance
 */
MapUp.prototype.addFeedLayer = function(szLayer,opt){
	maptune.addFeedLayer(szLayer,opt);
}
/**
 * end of namespace
 */

})();

// utf8 handling
// -----------------

function __hex2dec(n) {
	return parseInt(n,16);
}
function __decode_utf8( s )
{
	var text = "";
	if ( typeof(s) == "string" ){
		var sA = s.split("&#x");
		text = sA[0];
		for ( var i=1; i<sA.length; i++){
			text += String.fromCharCode(__hex2dec(sA[i].substr(0,2)));
			text += sA[i].substr(3,sA[i].length-3);
		}
	}
	return text; 
}
/**
 * sets the timer to zero
 */
var __timer_nMillisec = 0;
function __timer_reset(){
	var jetzt = new Date();
	__timer_nMillisec = jetzt.getTime();
}
/**
 * gets the elapsed time (in ms)
 */
function __timer_getMS(){
	var jetzt = new Date();
	var nActMilli = jetzt.getTime();
	return (nActMilli - __timer_nMillisec);
}
/**
 * gets the elapsed time (in ms)
 */
function __timer_getSEC(){
	var jetzt = new Date();
	var nActMilli = jetzt.getTime();
	return (nActMilli - __timer_nMillisec)/1000;
}

/**
 * gets the root of any url
 */
function __getUrlRoot(szUrl){
	var rootA = szUrl.split('/');
	rootA.pop();
	return rootA.join('/') + '/';
}


// -----------------------------
// EOF
// -----------------------------
