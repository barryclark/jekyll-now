/**********************************************************************
maptune.feed.js

$Comment: provides JavaScript for import of feeds
$Source :maptune.feed.js,v $

$InitialAuthor: guenter richter $
$InitialDate: 2012/01/15 $
$Author: guenter richter $
$Id:maptune.feed.js 1 2012-01-15 10:30:35Z Guenter Richter $

Copyright (c) Guenter Richter
$Log:maptune.feed.js,v $
**********************************************************************/

/** 
 * @fileoverview This file is a plugin for maptune.jsapi top import arbitrari georeferenced feeds
 *
 * @author Guenter Richter guenter.richter@ixmaps.com
 * @version 0.9
 */

/**
 * define namespace maptune
 */

// Auto-load scripts
//
// specify which feed parser to load by using
// <script src="maptune.feed.js?(feedtype1,feedtype2)" ...
// in your HTML
//
// for each feed type maptune.feed.feedtype.js will be loaded
// modules 'maptune.feed.parse.geojson.js,maptune.feed.parse.geojsonr.js,maptune.feed.parse.georss.js,maptune.feed.parse.kml.js' are always loaded
//
var scriptBase;
(function() {
	var providers = null;
	var modules = 'georss,geojson,geojsonr,kml';
	var scripts = document.getElementsByTagName('script');
	// Determine which scripts we need to load	
	for (var i = 0; i < scripts.length; i++) {
		var match = scripts[i].src.replace(/%20/g , '').match(/^(.*?)maptune\.feed\.js(\?\(\[?(.*?)\]?\))?$/);
		if (match !== null) {
			scriptBase = match[1];
			if (match[3]) {
				var settings = match[3].split(',[');
				providers = settings[0].replace(']' , '');
				modules += ',' + providers;
				if (settings[1]) {
					modules += ',' + settings[1];
				}
			}
			break;
	   }
	}
	modules = modules.replace(/ /g, '').split(',');

	// load the parse scripts
	var scriptTagStart = '<script type="text/javascript" src="' + scriptBase + 'maptune.feed.parse.';
	var scriptTagEnd = '.js"></script>';
	var scriptsAry = [];
	for (i = 0; i < modules.length; i++) {
		scriptsAry.push(scriptTagStart + modules[i] + scriptTagEnd);
	}
	// load cross domain script
	scriptsAry.push('<script type="text/javascript" src="' + scriptBase + 'maptune.feed.cross.js"></script>');
	// load fusion tables script
	scriptsAry.push('<script type="text/javascript" src="' + scriptBase + 'maptune.FusionTables.js"></script>');
	scriptsAry.push('<script type="text/javascript" src="' + scriptBase + 'maptune.query.FusionTables.js"></script>');
	scriptsAry.push('<script type="text/javascript" src="http://www.google.com/jsapi"></script>');

	document.write(scriptsAry.join(''));
})();

window.maptune = window.maptune || {};
maptune.jsapi = maptune.jsapi || {};
maptune.feed = maptune.feed || {};
maptune.feed.parse = maptune.feed.parse || {};
(function() {

var debug = false;

// ----------------------------------------------------
// objects and methods to define one maptune layer(set)
// ----------------------------------------------------
//
// use these within parser, to create maptune layer
//
/**
 * maptune LayerSet class 
 * @szName a name for the new layer(set)
 * @constructor
 * @throws 
 * @return a new layer set instance
 */
	maptune.feed.LayerSet = function(szName){
		this.type	= "Map";
		this.name	= szName?szName:"Feed";
		this.comment = "generated by maptune.feed";
		this.bbox = new Array(180,90,-180,-90);
		this.layers = new Array();
	};
/**
 * method to add a layer to the set 
 * @szName a name for the new layer
 * @return a new layer object
 */
	maptune.feed.LayerSet.prototype.addLayer = function(szName){
		var ret = new maptune.feed.Layer(szName);
		ret.parent = this;
		this.layers.push(ret);
		return ret;
	};

/**
 * maptune Layer class 
 * @szName a name for the layer
 * @constructor
 * @throws 
 * @return a new layer instance
 */
	maptune.feed.Layer = function(szName){
		this.type = "FeatureCollection";
		this.properties = { "name": szName ,
							 "description": "",
							 "Snippet": "",
							 "visibility": "1",
							 "open": "0",
							 "legendstyle": "CHECKSUBLAYER",
							 "icon": "./resources/icons/google/kml/paddle/red-diamond.png",
							 "end": "" };
		this.features = new Array();
	};
/**
 * method to add a feature (layer item) to a layer
 * @return a new feature object
 */
	maptune.feed.Layer.prototype.addFeature = function(szName){
		var ret = new maptune.feed.Feature(szName);
		ret.parent = this;
		this.features.push(ret);
		return ret;
	};

/**
 * maptune Feature class 
 * @szName a name for the feature
 * @constructor
 * @throws 
 * @return a new feature instance
 */
	maptune.feed.Feature = function(szName){
		this.type		=	"Feature";
		this.properties = { "name": szName,
							"description": "" ,
							"icon": "./resources/icons/google/kml/paddle/red-diamond.png",
							"smallicon": "./resources/icons/google/red-circle.png",
							"iconscale": "1.000000",
							"legenditem": "Test",
							"end": "" };
	};

/**
 * method to set the position of a feature
 * to be used for point features
 * @void
 */
	maptune.feed.Feature.prototype.setPosition = function(lat,lng){
		this.geometry   = { "type": "Point",
							"coordinates": new Array(lat,lng) };
		obj = this.parent.parent;
		if ( obj ){
			obj.bbox[0] = Math.min(obj.bbox[0],lat);
			obj.bbox[1] = Math.min(obj.bbox[1],lng);
			obj.bbox[2] = Math.max(obj.bbox[2],lat);
			obj.bbox[3] = Math.max(obj.bbox[3],lng);
		}
	};

/**
 * method to set the coordinates of a line
 * to be used for line features
 * @void
 */
	maptune.feed.Feature.prototype.setLine = function(latlngA){
		this.multigeometry   = [{ "type": "LineString",
								  "coordinates": latlngA }];
		obj = this.parent.parent;
		if ( obj ){
			for ( var i=0; i<latlngA.length; i++ ){
				obj.bbox[0] = Math.min(obj.bbox[0],latlngA[i][0]);
				obj.bbox[1] = Math.min(obj.bbox[1],latlngA[i][1]);
				obj.bbox[2] = Math.max(obj.bbox[2],latlngA[i][0]);
				obj.bbox[3] = Math.max(obj.bbox[3],latlngA[i][1]);
			}
		}
	};
/**
 * method to set the coordinates of a polygon
 * to be used for polygon features
 * @void
 */
	maptune.feed.Feature.prototype.setPolygon = function(latlngA){
		this.multigeometry   = [{ "type": "Polygon",
								  "coordinates": latlngA }];
		obj = this.parent.parent;
		if ( obj ){
			for ( var i=0; i<latlngA.length; i++ ){
				var coordA = latlngA[i];
				for ( var ii=0; ii<coordA.length; ii++ ){
					obj.bbox[0] = Math.min(obj.bbox[0],coordA[ii][0]);
					obj.bbox[1] = Math.min(obj.bbox[1],coordA[ii][1]);
					obj.bbox[2] = Math.max(obj.bbox[2],coordA[ii][0]);
					obj.bbox[3] = Math.max(obj.bbox[3],coordA[ii][1]);
				}
			}
		}
	};

// --------------------------------------
// handle feeds 
// --------------------------------------

/**
 * feed channel object  
 * @class a feed channel object
 * @constructor
 * @throws 
 * @return A new Channel
 */
	maptune.feed.Channel = Channel = function(szUrl){
		this.szUrl = szUrl;
	};

/**
 * add a feed to the map  
 * @param the URL of the feed
 * @param opt optional parameter object
 * @type void
 */
	maptune.feed.refreshOptA = [];
	maptune.feed.addFeed = function(szSource,opt,callback){

		// if called by setTimeout(), opt is a string (see below)
		// ------------------------------------------------------
		if ( typeof(opt) == "string" ){
			console.log(opt);
			opt = maptune.feed.refreshOptA[opt];
			console.log(opt);
			// no zoomto after refresh
			opt.flag = "";
		}

		//_TRACE("maptune.feed.addFeed: "+szSource);

		if ( typeof(opt) == "undefined" || !opt || !opt.type || !opt.format ){
			var szParam =	(!opt.type?"type ":"") +  
							(!opt.format?"format ":"");
			maptune.errorMessage("addFeed: missing parameter: "+szParam,2000);
			return false;
		}

		maptune.feed.unresolvedPosition = 0;

		if ( !callback ){
			callback = function(){};
		}

		// GR 23.05.2013 pass url for isLayerOfSource()
		opt.szSourceUrl = szSource;

		// check origin and get around cross domain restrictions by using a proxy
		// ----------------------------------------------------------------------
		if ( typeof(opt.proxy) == "undefined" || !opt.proxy ){
			if ( maptune.feed.crossDomain(szSource,opt,callback) ){
				return;
			}
		}

		if ( opt.format == 'json' ){
			maptune.message("loading",true);
			$.get(szSource,
				function(data){
					callback(maptune.feed.processFeed(data,opt));
				}).error(function() { maptune.errorMessage("error loading:"+szSource); });
		}
		if ( opt.format == 'jsonp' ){
			maptune.message("loading",true);
			$.getScript(szSource,
				function(data){
					eval("var dataP = "+opt.opt.JsonpCallBack);
					callback(maptune.feed.processFeed(dataP,opt));
				}).error(function() { maptune.errorMessage("error loading:"+szSource); });
		}
		if ( opt.format == 'text' ){
			maptune.message("loading",true);
            $.ajax({
                 type: "GET",
                 url: szSource,
                 dataType: "text",
                 success: function(xml) {
					// alert(xml);
					var test = JSON.parse(xml);
					// alert(test.value.items[0].content);
					szTest = "{\"map\":"+String(test.value.items[0].content);
					// alert(szTest);
					eval ("var obj='"+szTest+"');");
					// alert(obj);
					callback(maptune.feed.processFeed(xml,opt));
                 },
                 error: function(xml) {
					maptune.message("loading",false);
					maptune.errorMessage("error loading:"+szSource);
					callback(false);
                 }
            });
		}
		if ( opt.format == 'xml' ){
			maptune.message("loading",true);
            $.ajax({
                 type: "GET",
                 url: szSource,
                 dataType: "xml",
                 success: function(xml) {
					callback(maptune.feed.processFeed(xml,opt));
                 },
                 error: function(xml) {
 					maptune.message("loading",false);
					maptune.errorMessage("error loading:"+szSource+"<br><br>may be wrong data type definition ?");
					callback(false);
                }
            });
		}
		if ( opt.format == 'csv' ){
			maptune.message("loading",true);
			$.ajax({
				type: "GET",
				url: szSource,
				dataType: "text",
				success: function(data) {
					callback(maptune.feed.processFeed(data,opt));
				},
				error: function() {
					maptune.message("loading",false);
					maptune.errorMessage("error loading:"+szSource);
 					callback(false);
				}
			});
		}
	};


/**
 * process the feeds data feed to the map  
 * @param the data object received from the feed
 * @param opt optional parameter object
 * @type void
 */
	maptune.feed.processFeed = function(data,opt){

		//_TRACE("maptune.feed.processFeed: " + opt.type);

		if ( opt.format == "json" && typeof(data) == "string" ){
			data = JSON.parse(data);
		}

		if ( data == null ){
			maptune.message("loading",false,"x7");
			return false;
		}

		// parse the data and create maptune layer object
		// ---------------------------------------------
//		try {
			switch(opt.type){
				// deprecated, keep for compatibility, use 'MyMapsKLM_YQL'
				case 'Google_Maps_My_Map_KML_YQL':
					var feedLayer = this.parse.MyMapsKLM_YQL(data,opt);
					break;
				// deprecated, keep for compatibility, use 'MyMapsKLM'
				case 'Google_Maps_My_Map_KML':
					var feedLayer = this.parse.MyMapsKLM(data,opt);
					break;
				// the one and only for the future
				default:
					if ( eval("typeof(this.parse."+opt.type+")") == "function" ){
						var feedLayer = eval("this.parse."+opt.type+"(data,opt)");
					}else{
						_TRACE("load parser: " + 'maptune.feed.parse.' + opt.type + ".js");
						_TRACE("load parser: " + scriptBase + 'maptune.feed.parse.' + opt.type + ".js");

						$.getScript(scriptBase + 'maptune.feed.parse.' + opt.type + ".js")
						.done(function(script, textStatus) {
						  maptune.feed.processFeed(data,opt);
						  return;
						})
						.fail(function(jqxhr, settings, exception) {
							_TRACE("load parser: " + scriptBase + 'maptune.feed.parse.' + opt.type + ".js");
							$.getScript(scriptBase + 'plugins/maptune.feed.parse.' + opt.type + ".js")
							.done(function(script, textStatus) {
							  maptune.feed.processFeed(data,opt);
							  return;
							})
							.fail(function(jqxhr, settings, exception) {
							  maptune.message("loading",false,"x8");
							  maptune.errorMessage("'"+opt.type+"' unknown feed format !",2000);
							});
						});

						return;
					}
					break;
			}
//		} catch (e){
//			maptune.errorMessage("'"+opt.type+"' unknown feed format !",2000);
//			return false;
//		}

		if ( feedLayer == null ){
			maptune.message("loading",false,"x9");
			maptune.errorMessage("no valid data at<br><a href='"+opt.szSourceUrl+"' target='_blank'>"+opt.szSourceUrl+"</a>",2000);
			return false;
		}
		if ( feedLayer == "loading parser" ){
			return false;
		}

		if ( maptune.feed.unresolvedPosition ){
			maptune.errorMessage(maptune.feed.unresolvedPosition+" unresolved position(s)",2000);
		}

		// some display options for the new layer
		// ---------------------------------------------
		if ( opt.flag && opt.flag.match(/gallery/) ){
			feedLayer.layers[0].properties.fGallery = true;
		}
		if ( opt.flag && opt.flag.match(/open/) ){
			feedLayer.layers[0].sourcelegend = "expanded";
			feedLayer.layers[0].properties.open = true;
			feedLayer.layers[0].properties.visibility = true;
		}
		if ( opt.flag && opt.flag.match(/closed/) ){
			feedLayer.layers[0].sourcelegend = "collapsed";
//			feedLayer.layers[0].properties.open = false;
		}
		if ( opt.flag && opt.flag.match(/noinfo/) ){
			feedLayer.layers[0].fShowInfoInList = false;
		}
		if ( opt.flag && opt.flag.match(/showinfo/) ){
			feedLayer.layers[0].fShowInfoInList = true;
		}
		if ( opt.flag && opt.flag.match(/nolegend/) ){
			feedLayer.layers[0].fNoLegend = true;
		}
		if ( opt.flag && opt.flag.match(/sort/) ){
			feedLayer.layers[0].fSort = true;
		}

		if ( opt.opt ){
			if ( opt.opt.layer ){
				if ( opt.opt.layer.length ){
					for ( l in  opt.opt.layer ){
						maptune.jsapi.setLayerParam(opt.opt.layer[l]);
					}
				}else{
					maptune.jsapi.setLayerParam(opt.opt.layer);
				}
			}

			// refresh option ?
			// ----------------------------------------------------------------------
			if ( opt.opt.refresh ){
				// might be changed during former load, therefore reset to original
				opt.format = opt.opt.format;
				maptune.feed.refreshOptA[opt.szSourceUrl] = opt;
				feedLayer.layers[0].refreshTimeout = opt.refreshTimeout = setTimeout("maptune.feed.addFeed('"+opt.szSourceUrl+"','"+opt.szSourceUrl+"')",opt.opt.refresh*1000);
			}

		}

		// GR 04.11.2016 if time parser defined, but not yet done, parse time now
		// ----------------------------------------------------------------------
		if ( opt.opt.parser && opt.opt.parser.timeStart && !feedLayer.layers[0].features[0].properties.utime ){
			var parser = opt.opt.parser;

			var features = feedLayer.layers[0].features;

			for ( var i=0; i<features.length; i++ ){

				var feature = features[i];

				var timeStart = feature.properties[opt.opt.parser.timeStart] || 0;
				var timeEnd   = feature.properties[opt.opt.parser.timeEnd] || 0;

				// start time
				// ------------------
				if ( timeStart ){
					var d1 =  new Date(timeStart);
					if ( parser.timeParse ){
						d1 = parser.timeParse(timeStart);
					}
					feature.properties.utime = d1.getTime();
					feature.properties.utimeStart = d1.getTime();
				}

				// start time
				// ------------------
				if ( timeEnd ){
					var d2 =  new Date(timeEnd);
					if ( parser.timeParse ){
						d2 = parser.timeParse(timeEnd);
					}
					feature.properties.utimeEnd = d2.getTime();
				}
			}
		}




		// GR 23.05.2013 pass url
		feedLayer.szSourceUrl = opt.szSourceUrl;

		// finally add the layer 
		// ---------------------------------------------
		//_TRACE("addNewData from feed: "+feedLayer.name);
		maptune.jsapi.addNewData(feedLayer.name?feedLayer.name:"feed-test",feedLayer);
		maptune.message("loading",false,"x9");
		maptune.message("loading",false,"x9");

		if ( opt.flag && opt.flag.match(/zoomto/) ){
			maptune.jsapi.zoomToLayer(feedLayer.name);
		}

		return true;

	};



/**
 * end of namespace
 */

})();

// -----------------------------
// EOF
// -----------------------------
