---
layout: post
title: Basic concept
---

# 주요 개념
언리얼 공식문서 ```기본에 대한 이해/컴포넌트```와 ```프로그래밍 및 스크립팅/액터```에서 설명하고 있습니다.

## 월드
월드는 게임 콘텐츠를 구동하기 위해 필요한 필수적인 환경을 의미하며, 다음과 같은 요소를 제공한다. [버추얼 월드 제작](https://docs.unrealengine.com/5.0/ko/building-virtual-worlds-in-unreal-engine/)에서 레벨 디자인 관련 항목을 보실 수 있습니다.
* 공간
    - 가상 세계를 구성하는 3차원의 영역을 의미합니다. 게임 콘텐츠를 구성하는 물체는 월드의 영역 어딘가에 반드시 존재해야 합니다. 이를 위해 트랜스폼이라는 구조체를 제공합니다. 공간의 기본단위는 cm입니다.
* 시간
    - 가상 곤간에서 흐르는 시간입니다. 가상 세계에서의 시간은 초 단위로 현실 세계와 동일하게 흘러가지만, 시간을 멈추거나 느리게 혹은 빠르게 흘러가도록 시간의 스케일을 조절할 수 있습니다.
* 물리
    - 월드 공간에 배치된 물체에 작용하는 물리적인 환경입니다. 대표적인 물리 환경으로 중력을 들 수 있습니다. 공간에 배치된 물체가 월드로부터 물리적인 영향을 받으려면 콜리전 정보가 있어야 합니다.
* 렌더링
    - 엔진이 제공하는 시각적인 기능, 빛과 이에 반응하는 머티리얼로 구성됩니다. 언리얼 엔진은 현실 세계와 유사하게 동작하도록 물리 기반 렌더링 시스템을 제공합니다.

## 액터(Actor)
[액터](https://docs.unrealengine.com/4.26/ko/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/Actors/)는 **언리얼 엔진에서 콘텐츠를 구성하는 최소 단위의 물체입니다. 액터는 게임 월드의 특정 공간에서 자신에게 주어진 역활을 수행하는 물체를 의미합니다.** 월드에 존재하는 액터들의 목록은 월드 아웃라이너 윈도우에서 확인할 수 있습니다.

* 이름
    - 작업을 위해 액터에 부여된 명칭입니다. 여러 액터가 같은 이름을 가질 수 있습니다.
* 유형
    - 게임플레이에서 수행할 액터의 역활을 의미합니다. 프로그래밍 관점에서는 액터의 클래스 이름입니다.
* 트랜스폼
    - 액터는 반드시 월드에 존재해야 하므로 액터에는 항상 트랜스폼이 부여됩니다.
* 프로퍼티
    - 액터에 설정된 속성 값입니다. 액터의 유형에 따라 서로 다른 속성을 제공하며, 속성 값을 디테일 윈도우에서 편집해 같은 유형을 가진 액터가 서로 다른 일을 하게 만들 수 있습니다.
* 게임 로직
    - 액터에 특정 상황이 발생할 때 이에 대응할 구체적인 행동을 명령하기 위해서는 프로그래밍 코드가 필요합니다. 이를 게임 로직이라 합니다.

## 컴포넌트(Component)
액터의 주요 기능으로 크게 세가지로 나눌 수 있습니다. 플레이어에게 어떻게 보여질지 결정하는 시각적 기능, 액터의 이동과 액터들 간의 상호 동작을 어떻게 할 것인지 물리적 기능, 어떻게 움직일 것인지 움직임과 관련된 기능으로 나뉩니다.

[컴포넌트](https://docs.unrealengine.com/4.27/ko/Basics/Components/)는 액터에 추가시킬 수 있는 함수성 조각으로, 컴포넌트는 독립적으로 존재할 수는 없지만, 액터에 추가시킬 수 있는 자립적인 함수성 조각입니다.

예를 들면 스포트 라이트 컴포넌트는 액터가스포트 라이트처럼 빛을 내도록, 로테이팅 무브먼트 컴포넌트는 액터가 회전하도록, 오디오 컴포넌트는 액터가 사운드를 재생하도록 해줍니다.

또한 액터에 컴포넌트를 추가할 때, 그 액터 전체를 이루는 조각들을 함께 모아서 레벨에 배치하게 됩니다. 차를 예로 들면, 바퀴, 운전대, 차체, 라이트등이 컴포넌트로 간주되는 반면, 차 자체는 액터로 간주됩니다.

* 컴포넌트 핵심 유형은 다음과 같습니다.
    * UActorComponent : 베이스 컴포넌트입니다. **일반적으로 개념적 기능과 같은 것에 사용됩니다.**
    * USceneComponent : **씬 컴포넌트는 트랜스폼이 있는 액터 컴포넌트입니다. 트랜스폼은 위치, 회전, 스케일로 정의되는 월드상의 포지션을 나타냅니다.** 씬 컴포넌트는 계층구조 형태로 서로에게 붙일 수 있습니다.
    * UPrimitiveComponent : **그래픽적 표현이 있는 씬 컴포넌트를 말합니다.** 여기에는 재미난피직스 및 콜리전 세팅이 들어있습니다. 

* 컴포넌트 인스턴싱
    - 일반적인 서브 오브젝트의 기본 작동방식과는 상반되게, 액터 안에 서브 오브젝트로 생성된 컴포넌트는 인스턴스로 새엇ㅇ됩니다. 특정 클래스이 액터 인스턴스는 각각의 컴포넌트의 고유 인스턴스를 별도로 갖습니다.
* 컴포넌트 유형으로 대표적으로 AI 컴포넌트, 오디오 컴포넌트, 케이블 컴포넌트, 카메라 컴포넌트, 라이트 컴포넌트, 무브먼트 컴포넌트, 내비게이션 컴포넌트, 페이퍼 2D 컴포넌트, 피직스 컴포넌트, **컴포넌트 렌더링**, 셰이프 컴포넌트, **스켈레탈 메시 컴포넌트**, **스태틱 메시 컴포넌트**, 유틸리티 컴포넌트, 위젯 컴포넌트 등이 있습니다.
    - [참고자료](https://docs.unrealengine.com/4.27/ko/Basics/Components/)에서 보다 많은 내용을 볼 수 있습니다.

## 레벨
[레벨](https://docs.unrealengine.com/5.0/ko/levels-in-unreal-engine/)은 게임 개발 관점에서는 '플레이어에게 주어지는 스테이지'를 의미합니다. 잘 설계된 게임은 난이도에 따라 스테이지를 단계별로 기획해 플레이어에게 제공한다는 것을 생각한다면 전자와 후자의 개념은 어느 정도 유사하다고 할 수 있습니다.


# 액터(Actor)
액터란 레벨에 배치할 수 있는 오브젝트를 말합니다. 액터는 이동, 회전, 스케일과 같은 3D 트랜스폼을 지원하는 범용 클래스입니다.

* 액터는 게임플레이 코드를 통해 생성 및 소멸 가능합니다. 
* C++에서 AActor는 모든 액터의 베이스 클래스입니다.
* 액터는 트랜스폼 데이터를 직접 저장하지 않으며, 액터의 루트 컴포넌트에 트랜스폼 데이터가 존재하는 경우, 그 데이터를 사용합니다.
* AActor 클래스를 인스턴스로 새로 생성하는 것을 Spawn이라고 합니다. SpawnActor()를 사용할 수 있습니다.

액터는 한편으로 보면, Component라 불리는 특수 유형 Object를 담는 그릇으로 생각해 볼 수 있습니다. 여러가지 유형의 컴포넌트를 사용하여 액터의 이동 및 렌더링 방식 등을 제어할 수 있습니다. 

**액터의 또 다른 주요 기능은, 플레이 도중 네트워크를 통한 프로퍼티 및 함수 호출의 리플리케이션 입니다.**

## 액터 수명
[엑터의 수명 주기](https://docs.unrealengine.com/4.27/ko/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/Actors/ActorLifecycle/)를 읽을 수 있습니다.

* 참고로
    * 디스크에서 로드는 진한 퍼렁색
    * 에디터에서 플레이는 노란색
    * 스폰은 연한 파란색
    * 디퍼드 스폰은 주황색입니다.

* **Actor의 Construct 후 에 Component의 Construct가 호출되고, 그 다음 BeginPlay가 호출됩니다.**
Destroy 소멸 - 액터를 제거해야겠다 싶지만 게임플레이가 계속 진행중일 때 게임에서 수동으로 호출됩니다. 액터는 킬 대기 상태로 마킹되며, 레벨의 액터 배열에서 제거됩니다.

EndPlay 플레이 종료 - 액터의 수명이 막바지에 다다랐음을 보증하기 위해 여러 곳에서 호출됩니다.

* 액터는 RF_PendingKill 마킹되어 다음 가비지 컬렉션 주기 동안 deallocate (할당 해제)됩니다. 
* **pending kill (킬 대기상태)를 수동 검사하기 보다는, 보다 깔끔한 FWeakObjectPtr<AActor> 사용을 추천합니다.**

**OnDestroy 소멸시 - Destory (소멸)에 대한 구식(legacy) 반응입니다. 여기 있는 것들은 Level Transition (레벨 전환)이나 기타 게임 정리용 함수에 호출되는 EndPlay (플레이 종료)에 옮기는 것이 좋을 것입니다.**

* 위의 참조에서 추가적으로 고급 가비지 컬렉션에 대해서 설명하고 있습니다.
    * 클러스터는 IT용어에서 하드디스크의 논리 단위로 (하드디스크 드라이브에서 파일을 저장하는 단위로 1개 또는 복수의 섹터로 이루어진다. 작은 파일은 1개, 용량이 큰 파일은 여러 개의 클러스터를 사용하여 저장한다. 여러 개의 클러스터를 사용할 때 반드시 연결되어 있지는 않다. 여기저기 흩어져 있어도 그 위치와 순서를 기록한 FAT에 의하여 관리되므로, 한 번에 파일의 전체 내용을 읽을 수 있다.)사용됩니다.
    * [UE4 Garbage Collection](https://www.slideshare.net/QooJuice/ue4-garbage-collection-2)에 잘 설명되어 있습니다.

## 틱 그룹
* TG_PrePhysics
    - 액터가 물리 기반 어태치먼트를 포함해서 물리 오브젝트와 상호작용할 의도가 있는 경우 사용하는 틱 그룹입니다.
    - **이 틱 도중의 물리 시뮬레이션 데이터는 한 프레임 전, 즉 지난 프레임 화면에 렌더링된 데이터입니다.**
* TG_DuringPhysics
    - 이는 물리 시뮬레이션과 동시에 실행되기에, 이번 틱 도중의 물리 데이터가 전 프레임에서 온 것인지 현재 프레임에서 온 것인지 알 수 없습니다. 물리 시뮬레이션은 이 틱 그룹 내 언제든 완료 가능하며, 그러한 사실을 나타내는 정보를 제공하지는 않습니다.
    - 물리 시뮬레이션 데이터가 현재 또는 한 프레임 전의 것일 수 있으므로, 이 틱 그룹은 물리 데이터와 상관 없는 로직이나, 한 프레임 늦어져도 상관없는 경우에만 사용할 것을 추천합니다. **흔한 경우라면 인벤토리 화면 업데이트 또는 미니맵 표시의 경우인데, 물리 데이터가 완전히 무관하거나, 한 프레임 정도 지연되서 표시되도 별 상관이 없기 때문입니다.**
* TG_PostPhysics
    - 이 프레임의 물리 시뮬레이션 결과는 이 틱 그룹 실행 시점에서 완료됩니다.
    - **이 그룹은 무기나 무브먼트 트레이스에 사용하기 좋은데, 모든 물리 오브젝트는 최종 위치인 것으로 알려져 있어 이 프레임이 렌더링될 때 그려질 것이기 때문입니다.** 이는 슈팅 게임의 레이저 시야와 같은 것에 특히나 좋은데, 레이저 빔은 플레이어 총의 최종 위치에서 나오는 것처럼 보여야 하고, 한 프레임만 랙이 발생해도 매우 눈에 띄기 때문입니다.
* TG_PostUpdateWork
    - TG_PostPhysics 이후 실행됩니다. 역사적으로 그 주요 기능은 파티클 시스템에 최후의 순간 정보를 물려주는 것이었습니다.
    - TG_PostUpdateWork 는 카메라 업데이트 이후에 일어납니다. **카메라가 정확히 향하고 있는 방향에 의존하는 이펙트가 있는 경우라면, 그러한 이펙트 제어를 위한 액터는 이 곳에 넣는 것이 좋습니다.**
    - 프레임 내 완전 다른 모든 것 이후 실행시킬 게임 로직에 사용하기에도 좋은데, **격투 게임에서 같은 프레임에 서로를 잡으려 하는 두 캐릭터를 알아내려는 경우가 그렇습니다.**

## 액터 틱(Tick)
Tick, 틱이란 액터나 컴포넌트에 일정 간격, 보통 한 프레임에 한 번 코드 조각 또는 블루프린트 스크립트를 실행시키는 것을 말합니다.

**액터와 컴포넌트의 틱 주기는, 최소 틱 간격을 지정하지 않은 이상 한 프레임에 한 번입니다. 틱 발생은 틱 그룹에 따라 이루어지며, 틱 그룹은 코드 또는 블루프린트에서 할당할 수 있습니다.** 각 틱 그룹은 그에 할당된 모든 액터와 컴포넌트 틱이 완료된 이후에야 다음 틱 그룹을 시작합니다.

**틱 그룹에 더해, 액터나 컴포넌트는 틱 종속성을 설정할 수 있는데, 다른 액터나 컴포넌트의 틱 함수가 완료되기 전까지 틱이 일어나지 않도록 하는 것입니다.** 틱 그룹과 틱 종속성은 게임 내 물리 기반 동작과의 어우러짐이나, 다수의 액터 또는 컴포넌트가 연관된 순차적 게임플레이 동작이 어색하지 않도록 하는 데 있어서 매우 중요할 수 있습니다.

## 틱 종속성
하나의 액터 또는 컴포넌트에 다른 액터 또는 컴포넌트가 필요로 하는 데이터가 구성되는 경우에 특히나 유용합니다. 틱 그룹이 아닌 이 기능을 사용하는 이유라면, 액터가 같은 그룹에 있는 경우 다수의 액터가 병렬 업데이트일 수가 있기 때문입니다. 

* AddTickPrerequisiteActor, AddTickPrerequisiteComponent

? 액터가 병렬 업데이트일 수가 있다는 말이 먼 말이라냐?

# Player controller
[플레이어 컨트롤러](https://docs.unrealengine.com/4.27/ko/InteractiveExperiences/Framework/Controller/PlayerController/)

PlayerController 셋업시 그 안에 어떠한 함수성이, 또 Pawn 에는 어떠한 함수성이 있어야 하는지를 고려해야 합니다. **덜 복잡한 입력의 경우 Pawn 에서 모두 처리하는 것이 가능은 합니다. 하지만 게임 클라이언트 하나에 멀티 플레이어라든가, 실행시간에 동적으로 캐릭터를 바꾸는 기능같은 경우, PlayerController 에서 입력 처리를 하는 것이 나을 수도 있습니다.** 이 경우 PlayerController 에서 무엇을 할 지 결정한 다음 ("웅크리기 시작", "점프" 같은) 명령을 Pawn 에 내립니다.

또한 어떤 경우에는 입력 처리나 기타 함수성을 PlayerController 에 넣는 것이 필요할 수도 있습니다. PlayerController 는 게임 내도록 유지되는 반면, Pawn 은 휘발성이기 때문입니다. **예를 들어 데스매치 스타일 게임플레이에서 죽고 리스폰되면서 Pawn 은 달라지더라도 PlayerController 는 똑같을 수 있습니다. 이 경우 점수를 Pawn 에 유지했다면 리셋되겠지만, PlayerController 에 유지한 경우에는 리셋되지 않을 것입니다.**