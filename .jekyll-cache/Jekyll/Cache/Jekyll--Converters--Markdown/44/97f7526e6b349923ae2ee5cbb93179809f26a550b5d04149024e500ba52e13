I"<h1 id="ë¶„í• -ì •ë³µ-ì•Œê³ ë¦¬ì¦˜divide-and-conquer">ë¶„í•  ì •ë³µ ì•Œê³ ë¦¬ì¦˜(Divide and conquer)</h1>

<p>ê·¸ëŒ€ë¡œ í•´ê²°í•  ìˆ˜ ì—†ëŠ” ì»¤ë‹¤ë€ ë¬¸ì œë¥¼ ì‘ì€ ë¬¸ì œë¡œ ë¶„í• í•˜ì—¬ ë¬¸ì œë¥¼ í•´ê²°í•´ ë‚˜ê°€ëŠ” ë°©ë²•ë¡ ìœ¼ë¡œ,
ì¬ê·€í˜¸ì¶œì„ ì‚¬ìš©í•©ë‹ˆë‹¤.</p>

<h2 id="í•©ë³‘-ì •ë ¬-ì•Œê³ ë¦¬ì¦˜-merge-sort">í•©ë³‘ ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ (Merge sort)</h2>
<p>ì •ë ¬í•  ë°°ì—´ì„ ë” ì´ìƒ ë‚˜ëˆ ì§ˆ ìˆ˜ ì—†ëŠ” ë°°ì—´ë¡œ ë‚˜ëˆ„ì–´(Divide) 
ë°°ì—´ ë‹¨ìœ„ë³„ë¡œ ì •ë ¬(Conquer)í•´ ë‚˜ê°€ëŠ” ì•Œê³ ë¦¬ì¦˜ ì…ë‹ˆë‹¤.
ì¡´ í° ë…¸ì´ë§Œì— ì˜í•´ 1945ë…„ì— ê°œë°œë˜ì—ˆìŠµë‹ˆë‹¤.</p>

<p>#define MAX â€¦
int tempArray[MAX];</p>

<p>void merge(int array[], int left, int mid, int right)
{ <br />
    // compare and insert 
    int leftIndex = left; <br />
    int rightIndex = mid + 1;
    int tempIndex = left;   <br />
    while (leftIndex &lt;= mid &amp;&amp; rightIndex &lt;= right) <br />
    { <br />
        if (array[leftIndex] &lt;= array[rightIndex]) <br />
            tempArray[tempIndex++] = array[leftIndex++]; <br />
        else <br />
           tempArray[tempIndex++] = array[rightIndex++]; <br />
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// insert the rest   
if (leftIndex &gt; mid)   
{   
    while(rightIndex &lt;= right)   
        tempArray[tempIndex++] += list[rightIndex++];    
}   
else    
{   
    while(leftIndex &lt;= mid)   
        tempArray[tempIndex++] += list[leftIndex++];     
}   

// copy tempArray to array   
for (int i = left; i &lt;= right; i++)   
{   
   array[i] = tempArray[i];   
}    }   
</code></pre></div></div>

<p>void merge_sort(int array[], int left, int right) <br />
{ <br />
    if (left &lt; right) <br />
    { <br />
        int mid = (left + right) / 2;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    // partition   
    merge_sort(list, left, mid);   
    merge_sort(list, mid + 1, right);   

    // merge   
    merge(list, left, mid, right);   
}             }   
</code></pre></div></div>

<p>int main() <br />
{ <br />
   int array[MAX] = {â€¦} <br />
   merge_sort(array, 0, MAX - 1); <br />
}</p>

<p>ì´ê±° ì‹œê°„ë³µì¡ë„ ì–´ë–»ê²Œ êµ¬í•´ì•¼ í•´ìš”????â€¦
ì´ê±¸ ì–´ë–»ê²Œ í™œìš©í•œë°ìš”.</p>

<h2 id="í€µ-ì •ë ¬-ì•Œê³ ë¦¬ì¦˜quick-sort">í€µ ì •ë ¬ ì•Œê³ ë¦¬ì¦˜(Quick sort)</h2>
<p>ê¸°ì¤€ê°’ (pivod)ì„ ë‘ì–´ ì‘ìœ¼ë©´ ì™¼ìª½, í¬ë©´ ì˜¤ë¥¸ìª½ì— ë°°ì¹˜í•˜ëŠ” í–‰ìœ„ë¥¼ ë°˜ë³µí•˜ëŠ” 
Divide and conquer ë°©ì‹ì˜ ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤.</p>

<ol>
  <li>Pivotì„ ê¸°ì¤€ìœ¼ë¡œ ì™¼ìª½ì€ left partition, ì˜¤ë¥¸ìª½ì€ right partitionìœ¼ë¡œ ì¡ìŠµë‹ˆë‹¤.</li>
  <li>Partitionì˜ ë§¨ ì™¼ìª½ ì¸ë±ìŠ¤ë¥¼ L, ì˜¤ë¥¸ìª½ ì¸ë±ìŠ¤ë¥¼ Rë¡œ ë‘¡ë‹ˆë‹¤.</li>
  <li>LëŠ” ì •ë°©í–¥ìœ¼ë¡œ ì´ë™í•˜ë©´ì„œ ì›ì†Œë¥¼ ì°¨ë¡€ëŒ€ë¡œ ìˆœíšŒí•˜ë˜ Pivotë³´ë‹¤ í° ìˆ˜ë¥¼ ë°œê²¬í•˜ë©´ ë©ˆì¶¥ë‹ˆë‹¤.</li>
  <li>Rì€ ì—­ë°©í–¥ìœ¼ë¡œ ì´ë™í•˜ë©´ì„œ ì›ì†Œë¥¼ ì°¨ë¡€ëŒ€ë¡œ ìˆœíšŒí•˜ë˜ Pivotë³´ë‹¤ ì‘ì€ ìˆ˜ë¥¼ ë°œê²¬í•˜ë©´ ë©ˆì¶¥ë‹ˆë‹¤.</li>
  <li>Lê³¼ Rì´ ê°€ë¦¬í‚¤ëŠ” ì›ì†Œë“¤ì„ ì„œë¡œ ë°”ê¿‰ë‹ˆë‹¤.</li>
  <li>L &gt;= Rì´ë©´ ìˆœíšŒë¥¼ ë©ˆì¶”ê³  Pivotê³¼ L(í˜¹ì€ R)ì„ ì„œë¡œ ë°”ê¿‰ë‹ˆë‹¤.</li>
  <li>Partitionì´ ë” ì´ìƒ ë‚˜ë‰˜ì–´ì§€ì§€ ì•Šì„ ë•Œê¹Œì§€ Divide and conquer ë°©ì‹ìœ¼ë¡œ ì¬ê·€í˜¸ì¶œì„ ì‹¤í–‰í•˜ë©´ì„œ 1~7ë¥¼ ë°˜ë³µí•œë‹¤.</li>
</ol>

<p>ìˆœì„œì— ëŒ€í•œ ì •ë³´ê°€ ì—†ì„ ë•Œ ë‹¨ì¼ ìš”ì†Œë¥¼ ì„ íƒí•˜ëŠ” ê²ƒë³´ë‹¤ ì¤‘ì•™ê°’ì´ ìµœì ì˜ í”¼ë²—ì„ ë” ì˜ ì¶”ì •í•©ë‹ˆë‹¤.
ìŒâ€¦ ì´ìœ ëŠ” ëª°ë£¨.</p>

<p>void quickSort(int array[], const int&amp; min, const int&amp; max) <br />
{ <br />
    int pivotIndex = right;
    int left = min; <br />
    int right = pivotIndex - 1;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>while(left &lt; right)   
{   
    while (array[left] &lt; array[pivotIndex])   
        ++left;   

    while (array[right] &gt; array[pivotIndex])   
        --right;   

    if (left &lt; right)   
        swap(array[left], array[right]);   
}   
 
if (left &lt; pivotIndex)   
{   
    swap(array[pivotIndex], array[right]);   
    pivotIndex = right;   
}   

if (pivotIndex - min &gt; 1)   
    quickSort(array, min, pivotIndex - 1);      

if (max - pivotIndex &gt; 1)   
    quickSort(array, pivotIndex + 1; max);    }   
</code></pre></div></div>
:ET